<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib\server\opcua_server.js - The NodeOPCUA API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="The NodeOPCUA API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.52</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AcknowledgeMessage.html">AcknowledgeMessage</a></li>
                                <li><a href="../classes/ActivateSessionRequest.html">ActivateSessionRequest</a></li>
                                <li><a href="../classes/ActivateSessionResponse.html">ActivateSessionResponse</a></li>
                                <li><a href="../classes/AddNodesItem.html">AddNodesItem</a></li>
                                <li><a href="../classes/AddNodesRequest.html">AddNodesRequest</a></li>
                                <li><a href="../classes/AddNodesResponse.html">AddNodesResponse</a></li>
                                <li><a href="../classes/AddNodesResult.html">AddNodesResult</a></li>
                                <li><a href="../classes/AddReferencesItem.html">AddReferencesItem</a></li>
                                <li><a href="../classes/AddReferencesRequest.html">AddReferencesRequest</a></li>
                                <li><a href="../classes/AddReferencesResponse.html">AddReferencesResponse</a></li>
                                <li><a href="../classes/AddressSpace.html">AddressSpace</a></li>
                                <li><a href="../classes/AggregateConfiguration.html">AggregateConfiguration</a></li>
                                <li><a href="../classes/AnonymousIdentityToken.html">AnonymousIdentityToken</a></li>
                                <li><a href="../classes/ApplicationDescription.html">ApplicationDescription</a></li>
                                <li><a href="../classes/ApplicationType.html">ApplicationType</a></li>
                                <li><a href="../classes/Argument.html">Argument</a></li>
                                <li><a href="../classes/AsymmetricAlgorithmSecurityHeader.html">AsymmetricAlgorithmSecurityHeader</a></li>
                                <li><a href="../classes/AttributeIds.html">AttributeIds</a></li>
                                <li><a href="../classes/AttributeNameById.html">AttributeNameById</a></li>
                                <li><a href="../classes/AttributeOperand.html">AttributeOperand</a></li>
                                <li><a href="../classes/AxisInformation.html">AxisInformation</a></li>
                                <li><a href="../classes/BaseNode.html">BaseNode</a></li>
                                <li><a href="../classes/BaseUAObject.html">BaseUAObject</a></li>
                                <li><a href="../classes/BinaryStream.html">BinaryStream</a></li>
                                <li><a href="../classes/BinaryStreamSizeCalculator.html">BinaryStreamSizeCalculator</a></li>
                                <li><a href="../classes/BrowseDescription.html">BrowseDescription</a></li>
                                <li><a href="../classes/BrowseNextRequest.html">BrowseNextRequest</a></li>
                                <li><a href="../classes/BrowseNextResponse.html">BrowseNextResponse</a></li>
                                <li><a href="../classes/BrowsePath.html">BrowsePath</a></li>
                                <li><a href="../classes/BrowsePathResult.html">BrowsePathResult</a></li>
                                <li><a href="../classes/BrowsePathTarget.html">BrowsePathTarget</a></li>
                                <li><a href="../classes/BrowseRequest.html">BrowseRequest</a></li>
                                <li><a href="../classes/BrowseResponse.html">BrowseResponse</a></li>
                                <li><a href="../classes/BrowseResult.html">BrowseResult</a></li>
                                <li><a href="../classes/BuildInfo.html">BuildInfo</a></li>
                                <li><a href="../classes/CallMethodRequest.html">CallMethodRequest</a></li>
                                <li><a href="../classes/CallMethodResult.html">CallMethodResult</a></li>
                                <li><a href="../classes/CallRequest.html">CallRequest</a></li>
                                <li><a href="../classes/CallResponse.html">CallResponse</a></li>
                                <li><a href="../classes/CancelRequest.html">CancelRequest</a></li>
                                <li><a href="../classes/CancelResponse.html">CancelResponse</a></li>
                                <li><a href="../classes/ChannelSecurityToken.html">ChannelSecurityToken</a></li>
                                <li><a href="../classes/ChunkManager.html">ChunkManager</a></li>
                                <li><a href="../classes/ClientMonitoredItem.html">ClientMonitoredItem</a></li>
                                <li><a href="../classes/ClientSecureChannelLayer.html">ClientSecureChannelLayer</a></li>
                                <li><a href="../classes/ClientSession.html">ClientSession</a></li>
                                <li><a href="../classes/ClientSidePublishEngine.html">ClientSidePublishEngine</a></li>
                                <li><a href="../classes/ClientSubscription.html">ClientSubscription</a></li>
                                <li><a href="../classes/ClientTCP_transport.html">ClientTCP_transport</a></li>
                                <li><a href="../classes/CloseSecureChannelRequest.html">CloseSecureChannelRequest</a></li>
                                <li><a href="../classes/CloseSecureChannelResponse.html">CloseSecureChannelResponse</a></li>
                                <li><a href="../classes/CloseSessionRequest.html">CloseSessionRequest</a></li>
                                <li><a href="../classes/CloseSessionResponse.html">CloseSessionResponse</a></li>
                                <li><a href="../classes/ContentFilter.html">ContentFilter</a></li>
                                <li><a href="../classes/ContentFilterElement.html">ContentFilterElement</a></li>
                                <li><a href="../classes/ContentFilterElementResult.html">ContentFilterElementResult</a></li>
                                <li><a href="../classes/ContentFilterResult.html">ContentFilterResult</a></li>
                                <li><a href="../classes/CreateMonitoredItemsRequest.html">CreateMonitoredItemsRequest</a></li>
                                <li><a href="../classes/CreateMonitoredItemsResponse.html">CreateMonitoredItemsResponse</a></li>
                                <li><a href="../classes/CreateSessionRequest.html">CreateSessionRequest</a></li>
                                <li><a href="../classes/CreateSessionResponse.html">CreateSessionResponse</a></li>
                                <li><a href="../classes/CreateSubscriptionRequest.html">CreateSubscriptionRequest</a></li>
                                <li><a href="../classes/CreateSubscriptionResponse.html">CreateSubscriptionResponse</a></li>
                                <li><a href="../classes/cryptoutils.html">cryptoutils</a></li>
                                <li><a href="../classes/DataChangeFilter.html">DataChangeFilter</a></li>
                                <li><a href="../classes/DataChangeNotification.html">DataChangeNotification</a></li>
                                <li><a href="../classes/DataValue.html">DataValue</a></li>
                                <li><a href="../classes/DeleteMonitoredItemsRequest.html">DeleteMonitoredItemsRequest</a></li>
                                <li><a href="../classes/DeleteMonitoredItemsResponse.html">DeleteMonitoredItemsResponse</a></li>
                                <li><a href="../classes/DeleteNodesItem.html">DeleteNodesItem</a></li>
                                <li><a href="../classes/DeleteNodesRequest.html">DeleteNodesRequest</a></li>
                                <li><a href="../classes/DeleteNodesResponse.html">DeleteNodesResponse</a></li>
                                <li><a href="../classes/DeleteReferencesItem.html">DeleteReferencesItem</a></li>
                                <li><a href="../classes/DeleteReferencesRequest.html">DeleteReferencesRequest</a></li>
                                <li><a href="../classes/DeleteReferencesResponse.html">DeleteReferencesResponse</a></li>
                                <li><a href="../classes/DeleteSubscriptionsRequest.html">DeleteSubscriptionsRequest</a></li>
                                <li><a href="../classes/DeleteSubscriptionsResponse.html">DeleteSubscriptionsResponse</a></li>
                                <li><a href="../classes/DiagnosticInfo.html">DiagnosticInfo</a></li>
                                <li><a href="../classes/ElementOperand.html">ElementOperand</a></li>
                                <li><a href="../classes/EncodeDecode.html">EncodeDecode</a></li>
                                <li><a href="../classes/EndpointDescription.html">EndpointDescription</a></li>
                                <li><a href="../classes/Enum.html">Enum</a></li>
                                <li><a href="../classes/EnumValueType.html">EnumValueType</a></li>
                                <li><a href="../classes/ErrorMessage.html">ErrorMessage</a></li>
                                <li><a href="../classes/EUInformation.html">EUInformation</a></li>
                                <li><a href="../classes/EventFieldList.html">EventFieldList</a></li>
                                <li><a href="../classes/EventFilter.html">EventFilter</a></li>
                                <li><a href="../classes/EventFilterResult.html">EventFilterResult</a></li>
                                <li><a href="../classes/EventNotificationList.html">EventNotificationList</a></li>
                                <li><a href="../classes/ExpandedNodeId.html">ExpandedNodeId</a></li>
                                <li><a href="../classes/Factory.html">Factory</a></li>
                                <li><a href="../classes/FilterOperand.html">FilterOperand</a></li>
                                <li><a href="../classes/FilterOperator.html">FilterOperator</a></li>
                                <li><a href="../classes/FindServersRequest.html">FindServersRequest</a></li>
                                <li><a href="../classes/FindServersResponse.html">FindServersResponse</a></li>
                                <li><a href="../classes/GetEndpointsRequest.html">GetEndpointsRequest</a></li>
                                <li><a href="../classes/GetEndpointsResponse.html">GetEndpointsResponse</a></li>
                                <li><a href="../classes/HelloMessage.html">HelloMessage</a></li>
                                <li><a href="../classes/HistoryData.html">HistoryData</a></li>
                                <li><a href="../classes/HistoryModifiedData.html">HistoryModifiedData</a></li>
                                <li><a href="../classes/HistoryReadDetails.html">HistoryReadDetails</a></li>
                                <li><a href="../classes/HistoryReadRequest.html">HistoryReadRequest</a></li>
                                <li><a href="../classes/HistoryReadResponse.html">HistoryReadResponse</a></li>
                                <li><a href="../classes/HistoryReadResult.html">HistoryReadResult</a></li>
                                <li><a href="../classes/HistoryReadValueId.html">HistoryReadValueId</a></li>
                                <li><a href="../classes/HistoryUpdateRequest.html">HistoryUpdateRequest</a></li>
                                <li><a href="../classes/HistoryUpdateResponse.html">HistoryUpdateResponse</a></li>
                                <li><a href="../classes/HistoryUpdateResult.html">HistoryUpdateResult</a></li>
                                <li><a href="../classes/IssuedIdentityToken.html">IssuedIdentityToken</a></li>
                                <li><a href="../classes/LiteralOperand.html">LiteralOperand</a></li>
                                <li><a href="../classes/LocalizedText.html">LocalizedText</a></li>
                                <li><a href="../classes/MessageBuilder.html">MessageBuilder</a></li>
                                <li><a href="../classes/MessageBuilderBase.html">MessageBuilderBase</a></li>
                                <li><a href="../classes/MessageChunker.html">MessageChunker</a></li>
                                <li><a href="../classes/MessageSecurityMode.html">MessageSecurityMode</a></li>
                                <li><a href="../classes/ModelChangeStructure.html">ModelChangeStructure</a></li>
                                <li><a href="../classes/ModificationInfo.html">ModificationInfo</a></li>
                                <li><a href="../classes/ModifyMonitoredItemsRequest.html">ModifyMonitoredItemsRequest</a></li>
                                <li><a href="../classes/ModifyMonitoredItemsResponse.html">ModifyMonitoredItemsResponse</a></li>
                                <li><a href="../classes/ModifySubscriptionRequest.html">ModifySubscriptionRequest</a></li>
                                <li><a href="../classes/ModifySubscriptionResponse.html">ModifySubscriptionResponse</a></li>
                                <li><a href="../classes/MonitoredItem.html">MonitoredItem</a></li>
                                <li><a href="../classes/MonitoredItemCreateRequest.html">MonitoredItemCreateRequest</a></li>
                                <li><a href="../classes/MonitoredItemCreateResult.html">MonitoredItemCreateResult</a></li>
                                <li><a href="../classes/MonitoredItemModifyRequest.html">MonitoredItemModifyRequest</a></li>
                                <li><a href="../classes/MonitoredItemModifyResult.html">MonitoredItemModifyResult</a></li>
                                <li><a href="../classes/MonitoredItemNotification.html">MonitoredItemNotification</a></li>
                                <li><a href="../classes/MonitoringFilter.html">MonitoringFilter</a></li>
                                <li><a href="../classes/MonitoringParameters.html">MonitoringParameters</a></li>
                                <li><a href="../classes/MyStructure.html">MyStructure</a></li>
                                <li><a href="../classes/NodeCrawler.html">NodeCrawler</a></li>
                                <li><a href="../classes/NodeId.html">NodeId</a></li>
                                <li><a href="../classes/NodeIdType.html">NodeIdType</a></li>
                                <li><a href="../classes/NodeTypeDescription.html">NodeTypeDescription</a></li>
                                <li><a href="../classes/NotificationMessage.html">NotificationMessage</a></li>
                                <li><a href="../classes/opcua.html">opcua</a></li>
                                <li><a href="../classes/OPCUABaseServer.html">OPCUABaseServer</a></li>
                                <li><a href="../classes/OPCUAClient.html">OPCUAClient</a></li>
                                <li><a href="../classes/OPCUAClientBase.html">OPCUAClientBase</a></li>
                                <li><a href="../classes/OPCUASecureObject.html">OPCUASecureObject</a></li>
                                <li><a href="../classes/OPCUAServer.html">OPCUAServer</a></li>
                                <li><a href="../classes/OPCUAServerEndPoint
                
                A sever end point is listening to one port.html">OPCUAServerEndPoint
                
                A sever end point is listening to one port</a></li>
                                <li><a href="../classes/OpenSecureChannelRequest.html">OpenSecureChannelRequest</a></li>
                                <li><a href="../classes/OpenSecureChannelResponse.html">OpenSecureChannelResponse</a></li>
                                <li><a href="../classes/PacketAssembler.html">PacketAssembler</a></li>
                                <li><a href="../classes/ParsingResult.html">ParsingResult</a></li>
                                <li><a href="../classes/PublishRequest.html">PublishRequest</a></li>
                                <li><a href="../classes/PublishResponse.html">PublishResponse</a></li>
                                <li><a href="../classes/QualifiedName.html">QualifiedName</a></li>
                                <li><a href="../classes/QueryDataDescription.html">QueryDataDescription</a></li>
                                <li><a href="../classes/QueryDataSet.html">QueryDataSet</a></li>
                                <li><a href="../classes/QueryFirstRequest.html">QueryFirstRequest</a></li>
                                <li><a href="../classes/QueryFirstResponse.html">QueryFirstResponse</a></li>
                                <li><a href="../classes/QueryNextRequest.html">QueryNextRequest</a></li>
                                <li><a href="../classes/QueryNextResponse.html">QueryNextResponse</a></li>
                                <li><a href="../classes/Range.html">Range</a></li>
                                <li><a href="../classes/ReadAtTimeDetails.html">ReadAtTimeDetails</a></li>
                                <li><a href="../classes/ReaderState.html">ReaderState</a></li>
                                <li><a href="../classes/ReadEventDetails.html">ReadEventDetails</a></li>
                                <li><a href="../classes/ReadProcessedDetails.html">ReadProcessedDetails</a></li>
                                <li><a href="../classes/ReadRawModifiedDetails.html">ReadRawModifiedDetails</a></li>
                                <li><a href="../classes/ReadRequest.html">ReadRequest</a></li>
                                <li><a href="../classes/ReadResponse.html">ReadResponse</a></li>
                                <li><a href="../classes/ReadValueId.html">ReadValueId</a></li>
                                <li><a href="../classes/RedundantServer.html">RedundantServer</a></li>
                                <li><a href="../classes/Reference.html">Reference</a></li>
                                <li><a href="../classes/ReferenceDescription.html">ReferenceDescription</a></li>
                                <li><a href="../classes/ReferenceType.html">ReferenceType</a></li>
                                <li><a href="../classes/RegisteredServer.html">RegisteredServer</a></li>
                                <li><a href="../classes/RegisterNodesRequest.html">RegisterNodesRequest</a></li>
                                <li><a href="../classes/RegisterNodesResponse.html">RegisterNodesResponse</a></li>
                                <li><a href="../classes/RegisterServerRequest.html">RegisterServerRequest</a></li>
                                <li><a href="../classes/RegisterServerResponse.html">RegisterServerResponse</a></li>
                                <li><a href="../classes/RelativePath.html">RelativePath</a></li>
                                <li><a href="../classes/RelativePathElement.html">RelativePathElement</a></li>
                                <li><a href="../classes/RepublishRequest.html">RepublishRequest</a></li>
                                <li><a href="../classes/RepublishResponse.html">RepublishResponse</a></li>
                                <li><a href="../classes/RequestHeader.html">RequestHeader</a></li>
                                <li><a href="../classes/ResponseHeader.html">ResponseHeader</a></li>
                                <li><a href="../classes/SamplingIntervalDiagnostics.html">SamplingIntervalDiagnostics</a></li>
                                <li><a href="../classes/SecureMessageChunkManager.html">SecureMessageChunkManager</a></li>
                                <li><a href="../classes/SecurityPolicy.html">SecurityPolicy</a></li>
                                <li><a href="../classes/SecurityTokenRequestType.html">SecurityTokenRequestType</a></li>
                                <li><a href="../classes/SemanticChangeStructure.html">SemanticChangeStructure</a></li>
                                <li><a href="../classes/SequenceHeader.html">SequenceHeader</a></li>
                                <li><a href="../classes/SequenceNumberGenerator.html">SequenceNumberGenerator</a></li>
                                <li><a href="../classes/ServerDiagnosticsSummary.html">ServerDiagnosticsSummary</a></li>
                                <li><a href="../classes/ServerEngine.html">ServerEngine</a></li>
                                <li><a href="../classes/ServerSecureChannelLayer.html">ServerSecureChannelLayer</a></li>
                                <li><a href="../classes/ServerSession.html">ServerSession</a></li>
                                <li><a href="../classes/ServerSidePublishEngine.html">ServerSidePublishEngine</a></li>
                                <li><a href="../classes/ServerStatus.html">ServerStatus</a></li>
                                <li><a href="../classes/ServerTCP_transport.html">ServerTCP_transport</a></li>
                                <li><a href="../classes/ServiceCounter.html">ServiceCounter</a></li>
                                <li><a href="../classes/ServiceFault.html">ServiceFault</a></li>
                                <li><a href="../classes/SessionDiagnostics.html">SessionDiagnostics</a></li>
                                <li><a href="../classes/SessionSecurityDiagnostics.html">SessionSecurityDiagnostics</a></li>
                                <li><a href="../classes/SetMonitoringModeRequest.html">SetMonitoringModeRequest</a></li>
                                <li><a href="../classes/SetMonitoringModeResponse.html">SetMonitoringModeResponse</a></li>
                                <li><a href="../classes/SetPublishingModeRequest.html">SetPublishingModeRequest</a></li>
                                <li><a href="../classes/SetPublishingModeResponse.html">SetPublishingModeResponse</a></li>
                                <li><a href="../classes/SetTriggeringRequest.html">SetTriggeringRequest</a></li>
                                <li><a href="../classes/SetTriggeringResponse.html">SetTriggeringResponse</a></li>
                                <li><a href="../classes/SignatureData.html">SignatureData</a></li>
                                <li><a href="../classes/SignedSoftwareCertificate.html">SignedSoftwareCertificate</a></li>
                                <li><a href="../classes/SimpleAttributeOperand.html">SimpleAttributeOperand</a></li>
                                <li><a href="../classes/Simulator.html">Simulator</a></li>
                                <li><a href="../classes/StatusChangeNotification.html">StatusChangeNotification</a></li>
                                <li><a href="../classes/StatusCode.html">StatusCode</a></li>
                                <li><a href="../classes/Subscription.html">Subscription</a></li>
                                <li><a href="../classes/SubscriptionAcknowledgement.html">SubscriptionAcknowledgement</a></li>
                                <li><a href="../classes/SubscriptionDiagnostics.html">SubscriptionDiagnostics</a></li>
                                <li><a href="../classes/SymmetricAlgorithmSecurityHeader.html">SymmetricAlgorithmSecurityHeader</a></li>
                                <li><a href="../classes/TCP_transport.html">TCP_transport</a></li>
                                <li><a href="../classes/TCPErrorMessage.html">TCPErrorMessage</a></li>
                                <li><a href="../classes/TimestampsToReturn.html">TimestampsToReturn</a></li>
                                <li><a href="../classes/ToolBrowsePath.html">ToolBrowsePath</a></li>
                                <li><a href="../classes/TransferResult.html">TransferResult</a></li>
                                <li><a href="../classes/TransferSubscriptionsRequest.html">TransferSubscriptionsRequest</a></li>
                                <li><a href="../classes/TransferSubscriptionsResponse.html">TransferSubscriptionsResponse</a></li>
                                <li><a href="../classes/TranslateBrowsePathsToNodeIdsRequest.html">TranslateBrowsePathsToNodeIdsRequest</a></li>
                                <li><a href="../classes/TranslateBrowsePathsToNodeIdsResponse.html">TranslateBrowsePathsToNodeIdsResponse</a></li>
                                <li><a href="../classes/TypeSchema.html">TypeSchema</a></li>
                                <li><a href="../classes/UADataType.html">UADataType</a></li>
                                <li><a href="../classes/UAObject.html">UAObject</a></li>
                                <li><a href="../classes/UAObjectType.html">UAObjectType</a></li>
                                <li><a href="../classes/UAVariable.html">UAVariable</a></li>
                                <li><a href="../classes/UAVariableType.html">UAVariableType</a></li>
                                <li><a href="../classes/UnregisterNodesRequest.html">UnregisterNodesRequest</a></li>
                                <li><a href="../classes/UnregisterNodesResponse.html">UnregisterNodesResponse</a></li>
                                <li><a href="../classes/UserIdentityTokenType.html">UserIdentityTokenType</a></li>
                                <li><a href="../classes/UserNameIdentityToken.html">UserNameIdentityToken</a></li>
                                <li><a href="../classes/UserTokenPolicy.html">UserTokenPolicy</a></li>
                                <li><a href="../classes/Variant.html">Variant</a></li>
                                <li><a href="../classes/View.html">View</a></li>
                                <li><a href="../classes/ViewDescription.html">ViewDescription</a></li>
                                <li><a href="../classes/WriteRequest.html">WriteRequest</a></li>
                                <li><a href="../classes/WriteResponse.html">WriteResponse</a></li>
                                <li><a href="../classes/WriteValue.html">WriteValue</a></li>
                                <li><a href="../classes/X509IdentityToken.html">X509IdentityToken</a></li>
                                <li><a href="../classes/Xml2Json.html">Xml2Json</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/opcua.address_space.html">opcua.address_space</a></li>
                                <li><a href="../modules/opcua.address_space.types.html">opcua.address_space.types</a></li>
                                <li><a href="../modules/opcua.client.html">opcua.client</a></li>
                                <li><a href="../modules/opcua.datamodel.html">opcua.datamodel</a></li>
                                <li><a href="../modules/opcua.helpers.html">opcua.helpers</a></li>
                                <li><a href="../modules/opcua.miscellaneous.html">opcua.miscellaneous</a></li>
                                <li><a href="../modules/opcua.server.html">opcua.server</a></li>
                                <li><a href="../modules/opcua.server.simulation.html">opcua.server.simulation</a></li>
                                <li><a href="../modules/opcua.transport.html">opcua.transport</a></li>
                                <li><a href="../modules/services.browse.html">services.browse</a></li>
                                <li><a href="../modules/services.get_endpoints.html">services.get_endpoints</a></li>
                                <li><a href="../modules/services.historizing.html">services.historizing</a></li>
                                <li><a href="../modules/services.method.html">services.method</a></li>
                                <li><a href="../modules/services.read.html">services.read</a></li>
                                <li><a href="../modules/services.register.html">services.register</a></li>
                                <li><a href="../modules/services.session.html">services.session</a></li>
                                <li><a href="../modules/services.subscription.html">services.subscription</a></li>
                                <li><a href="../modules/services.write.html">services.write</a></li>
                                <li><a href="../modules/StatusCodes.html">StatusCodes</a></li>
                                <li><a href="../modules/xml2json.html">xml2json</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib\server\opcua_server.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;
/*global: require Buffer*/
/**
 * @module opcua.server
 */

require(&quot;requirish&quot;)._(module);
var s = require(&quot;lib/datamodel/structures&quot;);
var ApplicationType = s.ApplicationType;

var StatusCodes = require(&quot;lib/datamodel/opcua_status_code&quot;).StatusCodes;
var NumericRange = require(&quot;lib/datamodel/numeric_range&quot;).NumericRange;
var assert = require(&quot;better-assert&quot;);

var async = require(&quot;async&quot;);
var util = require(&quot;util&quot;);
var path = require(&quot;path&quot;);
var fs = require(&quot;fs&quot;);
var _ = require(&quot;underscore&quot;);
var url = require(&quot;url&quot;);

var utils =  require(&quot;lib/misc/utils&quot;);
var debugLog = utils.make_debugLog(__filename);

var ServerEngine = require(&quot;lib/server/server_engine&quot;).ServerEngine;
var LocalizedText = require(&quot;lib/datamodel/localized_text&quot;).LocalizedText;

var browse_service = require(&quot;lib/services/browse_service&quot;);
var read_service = require(&quot;lib/services/read_service&quot;);
var write_service = require(&quot;lib/services/write_service&quot;);
var subscription_service = require(&quot;lib/services/subscription_service&quot;);
var register_server_service = require(&quot;lib/services/register_server_service&quot;);
var translate_service = require(&quot;lib/services/translate_browse_paths_to_node_ids_service&quot;);
var session_service = require(&quot;lib/services/session_service&quot;);
var call_service = require(&quot;lib/services/call_service&quot;);
var endpoints_service = require(&quot;lib/services/get_endpoints_service&quot;);
var ServerState = require(&quot;schemas/39394884f696ff0bf66bacc9a8032cc074e0158e/ServerState_enum&quot;).ServerState;
var EndpointDescription = endpoints_service.EndpointDescription;

var TimestampsToReturn = read_service.TimestampsToReturn;

var ActivateSessionRequest = session_service.ActivateSessionRequest;
var ActivateSessionResponse = session_service.ActivateSessionResponse;

var CreateSessionRequest = session_service.CreateSessionRequest;
var CreateSessionResponse = session_service.CreateSessionResponse;


var CloseSessionRequest = session_service.CloseSessionRequest;
var CloseSessionResponse = session_service.CloseSessionResponse;

var DeleteMonitoredItemsRequest = subscription_service.DeleteMonitoredItemsRequest;
var DeleteMonitoredItemsResponse = subscription_service.DeleteMonitoredItemsResponse;

var RepublishRequest = subscription_service.RepublishRequest;
var RepublishResponse = subscription_service.RepublishResponse;

var PublishRequest = subscription_service.PublishRequest;
var PublishResponse = subscription_service.PublishResponse;

var CreateSubscriptionRequest = subscription_service.CreateSubscriptionRequest;
var CreateSubscriptionResponse = subscription_service.CreateSubscriptionResponse;

var DeleteSubscriptionsRequest = subscription_service.DeleteSubscriptionsRequest;
var DeleteSubscriptionsResponse = subscription_service.DeleteSubscriptionsResponse;

var CreateMonitoredItemsRequest = subscription_service.CreateMonitoredItemsRequest;
var CreateMonitoredItemsResponse = subscription_service.CreateMonitoredItemsResponse;

var ModifyMonitoredItemsRequest = subscription_service.ModifyMonitoredItemsRequest;
var ModifyMonitoredItemsResponse = subscription_service.ModifyMonitoredItemsResponse;
var MonitoredItemModifyResult = subscription_service.MonitoredItemModifyResult;

var MonitoredItemCreateResult = subscription_service.MonitoredItemCreateResult;
var SetPublishingModeRequest = subscription_service.SetPublishingModeRequest;
var SetPublishingModeResponse = subscription_service.SetPublishingModeResponse;

var CallRequest = call_service.CallRequest;
var CallResponse = call_service.CallResponse;

var ReadRequest = read_service.ReadRequest;
var ReadResponse = read_service.ReadResponse;

var WriteRequest = write_service.WriteRequest;
var WriteResponse = write_service.WriteResponse;

var ReadValueId = read_service.ReadValueId;

var BrowseRequest = browse_service.BrowseRequest;
var BrowseResponse = browse_service.BrowseResponse;

var BrowseNextRequest = browse_service.BrowseNextRequest;
var BrowseNextResponse = browse_service.BrowseNextResponse;

var RegisterNodesRequest = browse_service.RegisterNodesRequest;
var RegisterNodesResponse = browse_service.RegisterNodesResponse;
var UnregisterNodesRequest = browse_service.UnregisterNodesRequest;
var UnregisterNodesResponse = browse_service.UnregisterNodesResponse;

var TranslateBrowsePathsToNodeIdsRequest = translate_service.TranslateBrowsePathsToNodeIdsRequest;
var TranslateBrowsePathsToNodeIdsResponse = translate_service.TranslateBrowsePathsToNodeIdsResponse;

var RegisterServerRequest = register_server_service.RegisterServerRequest;
var RegisterServerResponse = register_server_service.RegisterServerResponse;


var NodeId = require(&quot;lib/datamodel/nodeid&quot;).NodeId;
var DataValue = require(&quot;lib/datamodel/datavalue&quot;).DataValue;
var DataType = require(&quot;lib/datamodel/variant&quot;).DataType;
var AttributeIds = require(&quot;lib/datamodel/attributeIds&quot;).AttributeIds;

var MonitoredItem = require(&quot;lib/server/monitored_item&quot;).MonitoredItem;

var View = require(&quot;lib/address_space/view&quot;).View;

var crypto = require(&quot;crypto&quot;);

var dump = require(&quot;lib/misc/utils&quot;).dump;
var constructFilename = require(&quot;lib/misc/utils&quot;).constructFilename;

var OPCUAServerEndPoint = require(&quot;lib/server/server_end_point&quot;).OPCUAServerEndPoint;

var OPCUABaseServer = require(&quot;lib/server/base_server&quot;).OPCUABaseServer;


var Factory = function Factory(engine) {
    assert(_.isObject(engine));
    this.engine = engine;
};

var factories = require(&quot;lib/misc/factories&quot;);

Factory.prototype.constructObject = function (id) {
    return factories.constructObject(id);
};

var default_maxAllowedSessionNumber   = 10;
var default_maxConnectionsPerEndpoint = 10;


function g_sendError(channel, message, ResponseClass, statusCode) {
    var response = new ResponseClass({
        responseHeader: {serviceResult: statusCode}
    });
    return channel.send_response(&quot;MSG&quot;, response, message);
}


var package_json_file = constructFilename(&quot;package.json&quot;);
var package_info = JSON.parse(fs.readFileSync(package_json_file));

var default_build_info = {
    productName: &quot;NODEOPCUA-SERVER&quot;,
    productUri: null, // &lt;&lt; should be same as default_server_info.productUri?
    manufacturerName: &quot;Node-OPCUA : MIT Licence ( see http://node-opcua.github.io/)&quot;,
    softwareVersion: package_info.version,
    buildDate: fs.statSync(package_json_file).mtime
};


/**
 * @class OPCUAServer
 * @extends  OPCUABaseServer
 * @uses ServerEngine
 * @param options
 * @param [options.defaultSecureTokenLifetime = 60000] {Number} the default secure token life time in ms.
 * @param [options.timeout=10000] {Number}              the HEL/ACK transaction timeout in ms. Use a large value
 *                                                      ( i.e 15000 ms) for slow connections or embedded devices.
 * @param [options.port= 26543] {Number}                the TCP port to listen to.
 * @param [options.maxAllowedSessionNumber = 10 ]       the maximum number of concurrent sessions allowed.
 *
 * @param [options.nodeset_filename]{Array&lt;String&gt;|String} the nodeset.xml files to load
 * @param [options.serverInfo = null]                   the information used in the end point description
 * @param [options.serverInfo.applicationUri = &quot;urn:NodeOPCUA-Server&quot;] {String}
 * @param [options.serverInfo.productUri = &quot;NodeOPCUA-Server&quot;]{String}
 * @param [options.serverInfo.applicationName = {text: &quot;applicationName&quot;}]{LocalizedText}
 * @param [options.serverInfo.gatewayServerUri = null]{String}
 * @param [options.serverInfo.discoveryProfileUri= null]{String}
 * @param [options.serverInfo.discoveryUrls = []]{Array&lt;String&gt;}
 * @param [options.securityPolicies= [SecurityPolicy.None,SecurityPolicy.Basic128Rsa15,SecurityPolicy.Basic256]]
 * @param [options.securityModes= [MessageSecurityMode.NONE,MessageSecurityMode.SIGN,MessageSecurityMode.SIGNANDENCRYPT]]
 * @param [options.allowAnonymous = true] tells if the server default endpoints should allow anonymous connection.
 * @param [options.userManager = null ] a object that implement a method isValidUser(userName,password) to check if the
 * @param [options.resourcePath=null] {String} resource Path is a string added at the end of the url such as &quot;/UA/Server&quot;
 * @param [options.alternateHostname=null] {String} alternate hostname to use
 *  UserNameIdentityToken is valid.
 * @constructor
 */
function OPCUAServer(options) {

    options = options || {};

    OPCUABaseServer.apply(this, arguments);

    var self = this;

    self.options = options;


    self.maxAllowedSessionNumber = options.maxAllowedSessionNumber || default_maxAllowedSessionNumber;
    self.maxConnectionsPerEndpoint = options.maxConnectionsPerEndpoint || default_maxConnectionsPerEndpoint;

    // build Info
    var buildInfo = _.clone(default_build_info);
    buildInfo = _.extend(buildInfo, options.buildInfo);

    // repair product name
    buildInfo.productUri = buildInfo.productUri || self.serverInfo.productUri;
    self.serverInfo.productUri = self.serverInfo.productUri || buildInfo.productUri;
    self.serverInfo.productName = self.serverInfo.productName || buildInfo.productName;

    self.engine = new ServerEngine({
        buildInfo: buildInfo,
        serverCapabilities: options.serverCapabilities,
        applicationUri: self.serverInfo.applicationUri
    });

    self.nonce = self.makeServerNonce();

    self.protocolVersion = 0;

    var port = options.port || 26543;
    assert(_.isFinite(port));

    self.objectFactory = new Factory(self.engine);

    // todo  should self.serverInfo.productUri  match self.engine.buildInfo.productUri ?

    options.allowAnonymous = ( options.allowAnonymous === undefined) ? true : options.allowAnonymous;

    //xx console.log(&quot; maxConnectionsPerEndpoint = &quot;,self.maxConnectionsPerEndpoint);

    // add the tcp/ip endpoint with no security
    var endPoint = new OPCUAServerEndPoint({
        port: port,
        defaultSecureTokenLifetime: options.defaultSecureTokenLifetime || 600000,
        timeout: options.timeout || 10000,
        certificate: self.getCertificate(),
        privateKey: self.getPrivateKey(),
        objectFactory: self.objectFactory,
        serverInfo: self.serverInfo,
        maxConnections: self.maxConnectionsPerEndpoint
    });

    endPoint.addStandardEndpointDescriptions({
        securityPolicies: options.securityPolicies,
        securityModes: options.securityModes,
        allowAnonymous: options.allowAnonymous,
        resourcePath: options.resourcePath || &quot;&quot;,
        hostname: options.alternateHostname
    });


    self.endpoints.push(endPoint);

    endPoint.on(&quot;message&quot;, function (message, channel) {
        self.on_request(message, channel);
    });

    endPoint.on(&quot;error&quot;, function (err) {
        console.log(&quot;OPCUAServer endpoint error&quot;, err);

        // set serverState to ServerState.Failed;
        self.engine.setServerState(ServerState.Failed);

        self.shutdown(function () {
        });
    });

    self.serverInfo.applicationType = ApplicationType.SERVER;


    self.userManager = options.userManager || {
            isValidUser: function (/*userName,password*/) {
                return false;
            }
        };
    assert(_.isFunction(self.userManager.isValidUser));

}
util.inherits(OPCUAServer, OPCUABaseServer);

OPCUAServer.registry = new (require(&quot;lib/misc/objectRegistry&quot;).ObjectRegistry)();


/**
 * total number of bytes written  by the server since startup
 * @property bytesWritten
 * @type {Number}
 */
OPCUAServer.prototype.__defineGetter__(&quot;bytesWritten&quot;, function () {

    return this.endpoints.reduce(function (accumulated, endpoint) {
        return accumulated + endpoint.bytesWritten;
    }, 0);
});

/**
 * total number of bytes read  by the server since startup
 * @property bytesRead
 * @type {Number}
 */
OPCUAServer.prototype.__defineGetter__(&quot;bytesRead&quot;, function () {
    return this.endpoints.reduce(function (accumulated, endpoint) {
        return accumulated + endpoint.bytesRead;
    }, 0);
});

/**
 * Number of transactions processed by the server since startup
 * @property transactionsCount
 * @type {Number}
 */
OPCUAServer.prototype.__defineGetter__(&quot;transactionsCount&quot;, function () {
    return this.endpoints.reduce(function (accumulated, endpoint) {
        return accumulated + endpoint.transactionsCount;
    }, 0);
});


/**
 * The server build info
 * @property buildInfo
 * @type {BuildInfo}
 */
OPCUAServer.prototype.__defineGetter__(&quot;buildInfo&quot;, function () {
    return this.engine.buildInfo;
});

/**
 * the number of connected channel on all existing end points
 * @property currentChannelCount
 * @type  {Number}
 *
 * TODO : move to base
 */
OPCUAServer.prototype.__defineGetter__(&quot;currentChannelCount&quot;, function () {

    var self = this;
    return self.endpoints.reduce(function (currentValue, endPoint) {
        return currentValue + endPoint.currentChannelCount;
    }, 0);
});


/**
 * The number of active subscriptions from all sessions
 * @property currentSubscriptionCount
 * @type {Number}
 */
OPCUAServer.prototype.__defineGetter__(&quot;currentSubscriptionCount&quot;, function () {
    var self = this;
    return self.engine.currentSubscriptionCount;
});

OPCUAServer.prototype.__defineGetter__(&quot;rejectedSessionCount&quot;, function () {
    return this.engine.rejectedSessionCount;
});
OPCUAServer.prototype.__defineGetter__(&quot;rejectedRequestsCount&quot;, function () {
    return this.engine.rejectedRequestsCount;
});
OPCUAServer.prototype.__defineGetter__(&quot;sessionAbortCount&quot;, function () {
    return this.engine.sessionAbortCount;
});
OPCUAServer.prototype.__defineGetter__(&quot;publishingIntervalCount&quot;, function () {
    return this.engine.publishingIntervalCount;
});

/**
 * create and register a new session
 * @method createSession
 * @return {ServerSession}
 */
OPCUAServer.prototype.createSession = function (options) {
    var self = this;
    return self.engine.createSession(options);
};

/**
 * the number of sessions currently active
 * @property currentSessionCount
 * @type {Number}
 */
OPCUAServer.prototype.__defineGetter__(&quot;currentSessionCount&quot;, function () {
    return this.engine.currentSessionCount;
});

/**
 * retrieve a session by authentication token
 * @method getSession
 *
 * @param authenticationToken
 * @param activeOnly search only within sessions that are not closed
 */
OPCUAServer.prototype.getSession = function (authenticationToken, activeOnly) {
    var self = this;
    return self.engine.getSession(authenticationToken, activeOnly);
};

/**
 * true if the server has been initialized
 * @property initialized
 * @type {Boolean}
 *
 */
OPCUAServer.prototype.__defineGetter__(&quot;initialized&quot;, function () {
    var self = this;
    return self.engine.addressSpace !== null;
});


/**
 * Initialize the server by installing default node set.
 *
 * @method initialize
 * @async
 *
 * This is a asynchronous function that requires a callback function.
 * The callback function typically completes the creation of custom node
 * and instruct the server to listen to its endpoints.
 *
 * @param {Function} done
 */
OPCUAServer.prototype.initialize = function (done) {

    var self = this;
    assert(!self.initialized);// already initialized ?

    OPCUAServer.registry.register(self);

    self.engine.initialize(self.options, function () {
        self.emit(&quot;post_initialize&quot;);
        done();
    });
};


/**
 * Initiate the server by starting all its endpoints
 * @method start
 * @async
 * @param done {Function}
 */
OPCUAServer.prototype.start = function (done) {

    var self = this;
    var tasks = [];
    if (!self.initialized) {
        tasks.push(function (callback) {
            self.initialize(callback);
        });
    }
    tasks.push(function (callback) {
        OPCUABaseServer.prototype.start.call(self, function (err) {
            if (err) {
                self.shutdown(function (/*err2*/) {
                    callback(err);
                });
            }
            else {
                callback();
            }
        });
    });

    async.series(tasks, done);

};

/**
 * shutdown all server endpoints
 * @method shutdown
 * @async
 * @param  [timeout=0] {Integer} the timeout before the server is actually shutted down
 * @param  done {Function}
 *
 *
 * @example
 *
 *    // shutdown immediatly
 *    server.shutdown(function(err) {
 *    });
 *
 *    // shutdown within 10 seconds
 *    server.shutdown(10000,function(err) {
 *    });
 */
OPCUAServer.prototype.shutdown = function (timeout, done) {


    if (_.isFunction(timeout) &amp;&amp; !done) {
        done = timeout;
        timeout = 10;
    }
    var self = this;

    debugLog(&quot;OPCUAServer#shutdown (timeout = &quot;,timeout,&quot;)&quot;);

    self.engine.setServerState(ServerState.Shutdown);

    setTimeout(function () {
        self.engine.shutdown();

        debugLog(&quot;OPCUAServer#shutdown: started&quot;);
        OPCUABaseServer.prototype.shutdown.call(self, function (err) {
            OPCUAServer.registry.unregister(self);
            debugLog(&quot;OPCUAServer#shutdown: completed&quot;);
            done(err);
        });

    }, timeout);

};

var computeSignature = require(&quot;lib/misc/security_policy&quot;).computeSignature;
var verifySignature = require(&quot;lib/misc/security_policy&quot;).verifySignature;

OPCUAServer.prototype.computeServerSignature = function (channel, clientCertificate, clientNonce) {
    var self = this;
    return computeSignature(clientCertificate, clientNonce, self.getPrivateKey(), channel.messageBuilder.securityPolicy);
};

var split_der = require(&quot;lib/misc/crypto_explore_certificate&quot;).split_der;

OPCUAServer.prototype.verifyClientSignature = function (session, channel, clientSignature) {

    var self = this;

    var clientCertificate = channel.receiverCertificate;
    var securityPolicy = channel.messageBuilder.securityPolicy;
    var serverCertificateChain = self.getCertificate();

    var serverCertificate = split_der(serverCertificateChain)[0];

    var result = verifySignature(serverCertificate, session.nonce, clientSignature, clientCertificate, securityPolicy);

    return result;
};


var minSessionTimeout = 10; // 10 milliseconds
var defaultSessionTimeout = 1000; // 1 second
var maxSessionTimeout = 1000 * 60 * 5; // 5 minutes

function _adjust_session_timeout(sessionTimeout) {
    var revisedSessionTimeout = sessionTimeout || defaultSessionTimeout;
    revisedSessionTimeout = Math.min(revisedSessionTimeout, maxSessionTimeout);
    revisedSessionTimeout = Math.max(revisedSessionTimeout, minSessionTimeout);
    //xx console.log(&quot;xxxxx requested time out = &quot;,request.requestedSessionTimeout,&quot; revised= &quot;,revisedSessionTimeout);
    return revisedSessionTimeout;
}

function channel_has_session(channel,session) {
    return session.channel === channel;
    //xx return (channel.session_nonce === session.nonce);
}

function channel_registerSession(channel,session) {
    assert(session.nonce &amp;&amp; session.nonce instanceof Buffer);
    session.channel = channel;
    //xx channel.session_nonce = session.nonce;
}

// session services
OPCUAServer.prototype._on_CreateSessionRequest = function (message, channel) {

    var server = this;
    var request = message.request;
    assert(request instanceof CreateSessionRequest);

    function rejectConnection(statusCode) {

        server.engine._rejectedSessionCount += 1;

        var response = new CreateSessionResponse({responseHeader: {serviceResult: statusCode}});
        channel.send_response(&quot;MSG&quot;, response, message);
        // and close !
    }


    // check if session count hasn&#x27;t reach the maximum allowed sessions
    if (server.currentSessionCount &gt;= server.maxAllowedSessionNumber) {
        return rejectConnection(StatusCodes.BadTooManySessions);
    }

    // Duration Requested maximum number of milliseconds that a Session should remain open without activity.
    // If the Client fails to issue a Service request within this interval, then the Server shall automatically
    // terminate the Client Session.
    var revisedSessionTimeout = _adjust_session_timeout(request.requestedSessionTimeout);


    // Release 1.02 page 27 OPC Unified Architecture, Part 4: CreateSession.clientNonce
    // A random number that should never be used in any other request. This number shall have a minimum length of 32
    // bytes. Profiles may increase the required length. The Server shall use this value to prove possession of
    // its application instance Certificate in the response.
    if (!request.clientNonce || request.clientNonce.length &lt; 32) {
        if (channel.securityMode !== endpoints_service.MessageSecurityMode.NONE) {
            console.log(&quot;SERVER with secure connection: Missing or invalid client Nonce &quot;.red, request.clientNonce &amp;&amp; request.clientNonce.toString(&quot;hex&quot;));
            return rejectConnection(StatusCodes.BadNonceInvalid);
        }
    }

    function validate_applicationUri(applicationUri, clientCertificate) {

        // if session is insecure there is no need to check certificate information
        if (channel.securityMode === endpoints_service.MessageSecurityMode.NONE) {
            return true; // assume correct
        }
        if (!clientCertificate || clientCertificate.length === 0) {
            return true;// can&#x27;t check
        }
        var exploreCertificate = require(&quot;lib/misc/crypto_explore_certificate&quot;).exploreCertificate;
        var e = exploreCertificate(clientCertificate);
        var applicationUriFromCert = e.tbsCertificate.extensions.subjectAltName.uniformResourceIdentifier[0];
        return applicationUriFromCert === applicationUri;
    }

    // check application spoofing
    // check if applicationUri in createSessionRequest matches applicationUri in client Certificate
    if (!validate_applicationUri(request.clientDescription.applicationUri, request.clientCertificate)) {
        return rejectConnection(StatusCodes.BadCertificateUriInvalid);
    }


    // see Release 1.02  27  OPC Unified Architecture, Part 4

    var session = server.createSession({sessionTimeout: revisedSessionTimeout});
    assert(session);
    assert(session.sessionTimeout === revisedSessionTimeout);

    session.clientDescription = request.clientDescription;
    session.sessionName = request.sessionName;

    // Depending upon on the  SecurityPolicy  and the  SecurityMode  of the  SecureChannel,  the exchange of
    // ApplicationInstanceCertificates   and  Nonces  may be optional and the signatures may be empty. See
    // Part  7  for the definition of  SecurityPolicies  and the handling of these parameters


    // serverNonce:
    // A random number that should never be used in any other request.
    // This number shall have a minimum length of 32 bytes.
    // The Client shall use this value to prove possession of its application instance
    // Certificate in the ActivateSession request.
    // This value may also be used to prove possession of the userIdentityToken it
    // specified in the ActivateSession request.
    //
    // ( this serverNonce will only be used up to the _on_ActivateSessionRequest
    //   where a new nonce will be created)
    session.nonce = server.makeServerNonce();
    session.secureChannelId = channel.secureChannelId;

    channel_registerSession(channel,session);

    var response = new CreateSessionResponse({
        // A identifier which uniquely identifies the session.
        sessionId: session.nodeId,

        // A unique identifier assigned by the Server to the Session.
        // The token used to authenticate the client in subsequent requests.
        authenticationToken: session.authenticationToken,

        revisedSessionTimeout: revisedSessionTimeout,

        serverNonce: session.nonce,

        // serverCertificate: type ApplicationServerCertificate
        // The application instance Certificate issued to the Server.
        // A Server shall prove possession by using the private key to sign the Nonce provided
        // by the Client in the request. The Client shall verify that this Certificate is the same as
        // the one it used to create the SecureChannel.
        // The ApplicationInstanceCertificate type is defined in OpCUA 1.03 part 4 - $7.2 page 108
        // If the securityPolicyUri is NONE and none of the UserTokenPolicies requires
        // encryption, the Server shall not send an ApplicationInstanceCertificate and the Client
        // shall ignore the ApplicationInstanceCertificate.
        serverCertificate: server.getCertificate(),

        // The endpoints provided by the server.
        // The Server shall return a set of EndpointDescriptions available for the serverUri
        // specified in the request.[...]
        // The Client shall verify this list with the list from a Discovery Endpoint if it used a Discovery
        // Endpoint to fetch the EndpointDescriptions.
        // It is recommended that Servers only include the endpointUrl, securityMode,
        // securityPolicyUri, userIdentityTokens, transportProfileUri and securityLevel with all
        // other parameters set to null. Only the recommended parameters shall be verified by
        // the client.
        serverEndpoints: server._get_endpoints(),

        //This parameter is deprecated and the array shall be empty.
        serverSoftwareCertificates: null,

        // This is a signature generated with the private key associated with the
        // serverCertificate. This parameter is calculated by appending the clientNonce to the
        // clientCertificate and signing the resulting sequence of bytes.
        // The SignatureAlgorithm shall be the AsymmetricSignatureAlgorithm specified in the
        // SecurityPolicy for the Endpoint.
        // The SignatureData type is defined in 7.30.
        serverSignature: server.computeServerSignature(channel, request.clientCertificate, request.clientNonce),

        // The maximum message size accepted by the server
        // The Client Communication Stack should return a Bad_RequestTooLarge error to the
        // application if a request message exceeds this limit.
        // The value zero indicates that this parameter is not used.
        maxRequestMessageSize: 0x4000000

    });

    server.emit(&quot;create_session&quot;, session);

    session.on(&quot;session_closed&quot;, function (session, deleteSubscriptions) {
        server.emit(&quot;session_closed&quot;, session, deleteSubscriptions);
    });

    if (server.isAuditing) {

        // ----------------------------------------------------------------------------------------------------------------
        server.raiseEvent(&quot;AuditCreateSessionEventType&quot;, {

            /* part 5 -  6.4.3 AuditEventType */
            actionTimeStamp:    {dataType: &quot;DateTime&quot;, value: new Date()},
            status:             {dataType: &quot;Boolean&quot;, value: true},

            serverId:           {dataType: &quot;String&quot;, value: &quot;&quot;},

            // ClientAuditEntryId contains the human-readable AuditEntryId defined in Part 3.
            clientAuditEntryId: {dataType: &quot;String&quot;, value: &quot;&quot;},

            // The ClientUserId identifies the user of the client requesting an action. The ClientUserId can be
            // obtained from the UserIdentityToken passed in the ActivateSession call.
            clientUserId:       {dataType: &quot;String&quot;, value: &quot;&quot; },

            sourceName:         {dataType: &quot;String&quot;, value: &quot;Session/CreateSession&quot;},

            /* part 5 - 6.4.7 AuditSessionEventType */
            sessionId:          {dataType: &quot;NodeId&quot;, value: session.nodeId},

            /* part 5 - 6.4.8 AuditCreateSessionEventType */
            // SecureChannelId shall uniquely identify the SecureChannel. The application shall use the same identifier in
            // all AuditEvents related to the Session Service Set (AuditCreateSessionEventType, AuditActivateSessionEventType
            // and their subtypes) and the SecureChannel Service Set (AuditChannelEventType and its subtypes
            secureChannelId: {dataType: &quot;String&quot;, value: session.channel.secureChannelId.toString()},

            // Duration
            revisedSessionTimeout : { dataType: &quot;Duration&quot; ,  value: session.sessionTimeout },

            // clientCertificate
            clientCertificate: { dataType: &quot;ByteString&quot;, value: session.channel.clientCertificate },

            // clientCertificateThumbprint
            clientCertificateThumbprint: { dataType: &quot;ByteString&quot;, value: thumbprint(session.channel.clientCertificate) }

        });
    }
    // ----------------------------------------------------------------------------------------------------------------

    assert(response.authenticationToken);
    channel.send_response(&quot;MSG&quot;, response, message);
};

var UserNameIdentityToken = session_service.UserNameIdentityToken;
var AnonymousIdentityToken = session_service.AnonymousIdentityToken;
var securityPolicy_m = require(&quot;lib/misc/security_policy&quot;);
var SecurityPolicy = securityPolicy_m.SecurityPolicy;


function adjustSecurityPolicy(channel, userTokenPolicy_securityPolicyUri) {
    // check that userIdentityToken
    var securityPolicy = securityPolicy_m.fromURI(userTokenPolicy_securityPolicyUri);

    // if the security policy is not specified we use the session security policy
    if (securityPolicy === SecurityPolicy.Invalid) {
        securityPolicy = securityPolicy_m.fromURI(channel.clientSecurityHeader.securityPolicyUri);
        assert(securityPolicy);
    }
    return securityPolicy;
}
OPCUAServer.prototype.isValidUserNameIdentityToken = function (channel, session, userTokenPolicy, userIdentityToken) {

    var self = this;

    assert(userIdentityToken instanceof UserNameIdentityToken);

    var securityPolicy = adjustSecurityPolicy(channel, userTokenPolicy.securityPolicyUri);

    var cryptoFactory = securityPolicy_m.getCryptoFactory(securityPolicy);
    if (!cryptoFactory) {
        throw new Error(&quot; Unsupported security Policy&quot;);
    }

    if (userIdentityToken.encryptionAlgorithm !== cryptoFactory.asymmetricEncryptionAlgorithm) {
        console.log(&quot;invalid encryptionAlgorithm&quot;);
        console.log(&quot;userTokenPolicy&quot;, userTokenPolicy.toString());
        console.log(&quot;userTokenPolicy&quot;, userIdentityToken.toString());
        return false;
    }
    var userName = userIdentityToken.userName;
    var password = userIdentityToken.password;
    if (!userName || !password) {
        return false;
    }
    return true;
};

OPCUAServer.prototype.userNameIdentityTokenAuthenticateUser = function (channel, session, userTokenPolicy, userIdentityToken) {
    var self = this;
    assert(userIdentityToken instanceof UserNameIdentityToken);
    assert(self.isValidUserNameIdentityToken(channel, session, userTokenPolicy, userIdentityToken));

    var securityPolicy = adjustSecurityPolicy(channel, userTokenPolicy.securityPolicyUri);

    var serverPrivateKey = self.getPrivateKey();

    var serverNonce = session.nonce;
    assert(serverNonce instanceof Buffer);

    var cryptoFactory = securityPolicy_m.getCryptoFactory(securityPolicy);
    if (!cryptoFactory) {
        throw new Error(&quot; Unsupported security Policy&quot;);
    }
    var userName = userIdentityToken.userName;
    var password = userIdentityToken.password;

    var buff = cryptoFactory.asymmetricDecrypt(password, serverPrivateKey);
    var length = buff.readUInt32LE(0) - serverNonce.length;
    password = buff.slice(4, 4 + length).toString(&quot;utf-8&quot;);
    return self.userManager.isValidUser(userName, password);

};


function findUserTokenByPolicy(endpoint_description, policyId) {
    assert(endpoint_description instanceof EndpointDescription);
    var r = _.filter(endpoint_description.userIdentityTokens, function (userIdentity) {
        // assert(userIdentity instanceof UserTokenPolicy)
        assert(userIdentity.tokenType);
        return userIdentity.policyId === policyId;
    });
    return r.length === 0 ? null : r[0];
}

OPCUAServer.prototype.isValidUserIdentityToken = function (channel, session, userIdentityToken) {

    var self = this;
    assert(userIdentityToken);

    var endpoint_desc = channel.endpoint;
    assert(endpoint_desc instanceof EndpointDescription);

    var userTokenPolicy = findUserTokenByPolicy(endpoint_desc, userIdentityToken.policyId);
    if (!userTokenPolicy) {
        // cannot find token with this policyId
        return false;
    }
    //
    if (userIdentityToken instanceof UserNameIdentityToken) {
        return self.isValidUserNameIdentityToken(channel, session, userTokenPolicy, userIdentityToken);
    }
    return true;
};
OPCUAServer.prototype.isUserAuthorized = function (channel, session, userIdentityToken) {

    var self = this;
    assert(userIdentityToken);

    var endpoint_desc = channel.endpoint;
    assert(endpoint_desc instanceof EndpointDescription);

    var userTokenPolicy = findUserTokenByPolicy(endpoint_desc, userIdentityToken.policyId);
    assert(userTokenPolicy);
    // find if a userToken exists
    if (userIdentityToken instanceof UserNameIdentityToken) {
        return self.userNameIdentityTokenAuthenticateUser(channel, session, userTokenPolicy, userIdentityToken);
    }
    return true;

};

OPCUAServer.prototype.makeServerNonce = function () {
    return crypto.randomBytes(32);
};

function sameIdentityToken(token1, token2) {


    if (token1 instanceof UserNameIdentityToken) {
        if (!token2 instanceof UserNameIdentityToken) {
            return false;
        }
        if (token1.userName !== token2.userName) {
            return false;
        }
        if (token1.password.toString(&quot;hex&quot;) !== token2.password.toString(&quot;hex&quot;)) {
            return false;
        }
    } else if (token1 instanceof AnonymousIdentityToken) {

        if (!token2 instanceof AnonymousIdentityToken) {
            return false;
        }
        if (token1.policyId !== token2.policyId) {
            return false;
        }
        return true;

    }
    assert(0, &quot; Not implemented yet&quot;);
    return false;
}
function thumbprint(certificate) {
    return certificate ? certificate.toString(&quot;base64&quot;) : &quot;&quot;;
}

// TODO : implement this:
//
// When the ActivateSession Service is called for the first time then the Server shall reject the request
// if the SecureChannel is not same as the one associated with the CreateSession request.
// Subsequent calls to ActivateSession may be associated with different SecureChannels. If this is the
// case then the Server shall verify that the Certificate the Client used to create the new
// SecureChannel is the same as the Certificate used to create the original SecureChannel. In addition,
// the Server shall verify that the Client supplied a UserIdentityToken that is identical to the token
// currently associated with the Session. Once the Server accepts the new SecureChannel it shall
// reject requests sent via the old SecureChannel.
/**
 *
 * @method _on_ActivateSessionRequest
 * @param message {Buffer}
 * @param channel {ServerSecureChannelLayer}
 * @private
 *
 *
 */
OPCUAServer.prototype._on_ActivateSessionRequest = function (message, channel) {

    var server = this;
    var request = message.request;
    assert(request instanceof ActivateSessionRequest);

    // get session from authenticationToken
    var authenticationToken = request.requestHeader.authenticationToken;

    var session = server.getSession(authenticationToken);


    function rejectConnection(statusCode) {
        server.engine._rejectedSessionCount += 1;
        var response = new ActivateSessionResponse({responseHeader: {serviceResult: statusCode}});

        channel.send_response(&quot;MSG&quot;, response, message);
        // and close !
    }

    var response;

    /* istanbul ignore next */
    if (!session) {
        console.log(&quot; Bad Session in  _on_ActivateSessionRequest&quot;.yellow.bold, authenticationToken.value.toString(&quot;hex&quot;));
        return rejectConnection(StatusCodes.BadSessionNotActivated);
    }

    // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29
    // When the ActivateSession  Service  is called f or the first time then the Server shall reject the request
    // if the  SecureChannel  is not same as the one associated with the  CreateSession  request.
    if (session.status === &quot;new&quot;) {
        //xx if (channel.session_nonce !== session.nonce) {
        if (!channel_has_session(channel,session)) {
            // it looks like session activation is being using a channel that is not the
            // one that have been used to create the session
            console.log(&quot; channel.session_nonce === &quot; + session.nonce.toString(&quot;hex&quot;));
            return rejectConnection(StatusCodes.BadSessionNotActivated);
        }
    }

    // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29
    // ... Subsequent calls to  ActivateSession  may be associated with different  SecureChannels.  If this is the
    // case then  the  Server  shall verify that the  Certificate  the  Client  used to create the new
    // SecureChannel  is the same as the  Certificate  used to create the original  SecureChannel.

    if (session.status === &quot;active&quot;) {

        if (session.channel.secureChannelId !== channel.secureChannelId) {

            console.log(&quot; Session is being transferred from channel&quot;,
                session.channel.secureChannelId.toString().cyan,
                &quot; to channel &quot;, channel.secureChannelId.toString().cyan);

            // session is being reassigned to a new Channel,
            // we shall verify that the certificate used to create the Session is the same as the current channel certificate.
            var old_channel_cert_thumbprint = thumbprint(session.channel.clientCertificate);
            var new_channel_cert_thumbprint = thumbprint(channel.clientCertificate);
            if (old_channel_cert_thumbprint !== new_channel_cert_thumbprint) {
                return rejectConnection(StatusCodes.BadNoValidCertificates); // not sure about this code !
            }

            // ... In addition the Server shall verify that the  Client  supplied a  UserIdentityToken  that is   identical to
            // the token currently associated with the  Session reassign session to new channel.
            if (!sameIdentityToken(session.userIdentityToken, request.userIdentityToken)) {
                return rejectConnection(StatusCodes.BadIdentityChangeNotSupported); // not sure about this code !
            }
        }

        session.changeToChannel(channel);
        assert(session.channel.secureChannelId === channel.secureChannelId);


    } else if (session.status === &quot;screwed&quot;) {
        // session has been used before being activated =&gt; this should be detected and session should be dismissed.
        return rejectConnection(StatusCodes.BadSessionClosed);
    } else if (session.status === &quot;closed&quot;) {
        console.log(&quot; Bad Session Closed in  _on_ActivateSessionRequest&quot;.yellow.bold, authenticationToken.value.toString(&quot;hex&quot;));
        return rejectConnection(StatusCodes.BadSessionClosed);
    }

    // verify clientSignature provided by the client
    if (!server.verifyClientSignature(session, channel, request.clientSignature, session.clientCertificate)) {
        return rejectConnection(StatusCodes.BadApplicationSignatureInvalid);
    }

    // check request.userIdentityToken is correct ( expected type and correctly formed)
    if (!server.isValidUserIdentityToken(channel, session, request.userIdentityToken)) {
        return rejectConnection(StatusCodes.BadIdentityTokenInvalid);
    }
    session.userIdentityToken = request.userIdentityToken;

    // check if user access is granted
    if (!server.isUserAuthorized(channel, session, request.userIdentityToken)) {
        return rejectConnection(StatusCodes.BadUserAccessDenied);
    }

    // extract : OPC UA part 4 - 5.6.3
    // Once used, a serverNonce cannot be used again. For that reason, the Server returns a new
    // serverNonce each time the ActivateSession Service is called.
    session.nonce = server.makeServerNonce();

    session.status = &quot;active&quot;;

    response = new ActivateSessionResponse({serverNonce: session.nonce});
    channel.send_response(&quot;MSG&quot;, response, message);

    function userIdentityTokenPasswordRemoved(userIdentityToken) {
        var a = userIdentityToken;
        // to do remove password
        return a;
    }

    // send OPCUA Event Notification
    // see part 5 : 6.4.3 AuditEventType
    //              6.4.7 AuditSessionEventType
    //              6.4.10 AuditActivateSessionEventType
    var VariantArrayType = require(&quot;lib/datamodel/variant&quot;).VariantArrayType;
    assert(session.nodeId); // sessionId
    //xx assert(session.channel.clientCertificate instanceof Buffer);
    assert(session.sessionTimeout &gt; 0);

    if (server.isAuditing) {
        server.raiseEvent(&quot;AuditActivateSessionEventType&quot;, {

            /* part 5 -  6.4.3 AuditEventType */
            actionTimeStamp:    {dataType: &quot;DateTime&quot;, value: new Date()},
            status:             {dataType: &quot;Boolean&quot;, value: true},

            serverId:           {dataType: &quot;String&quot;, value: &quot;&quot;},

            // ClientAuditEntryId contains the human-readable AuditEntryId defined in Part 3.
            clientAuditEntryId: {dataType: &quot;String&quot;, value: &quot;&quot;},

            // The ClientUserId identifies the user of the client requesting an action. The ClientUserId can be
            // obtained from the UserIdentityToken passed in the ActivateSession call.
            clientUserId:       {dataType: &quot;String&quot;, value: &quot;cc&quot;},

            sourceName:         {dataType: &quot;String&quot;, value: &quot;Session/ActivateSession&quot;},

            /* part 5 - 6.4.7 AuditSessionEventType */
            sessionId:          {dataType: &quot;NodeId&quot;, value: session.nodeId},

            /* part 5 - 6.4.10 AuditActivateSessionEventType */
            clientSoftwareCertificates: {
                dataType: &quot;ExtensionObject&quot; /* SignedSoftwareCertificate */,
                arrayType: VariantArrayType.Array,
                value: []
            },
            // UserIdentityToken reflects the userIdentityToken parameter of the ActivateSession Service call.
            // For Username/Password tokens the password should NOT be included.
            userIdentityToken: {
                dataType: &quot;ExtensionObject&quot; /*  UserIdentityToken */,
                value: userIdentityTokenPasswordRemoved(session.userIdentityToken)
            },

            // SecureChannelId shall uniquely identify the SecureChannel. The application shall use the same identifier
            // in all AuditEvents related to the Session Service Set (AuditCreateSessionEventType,
            // AuditActivateSessionEventType and their subtypes) and the SecureChannel Service Set
            // (AuditChannelEventType and its subtypes).
            secureChannelId: {dataType: &quot;String&quot;, value: session.channel.secureChannelId.toString()}

        });
    }


};

var makeNodeId = require(&quot;lib/datamodel/nodeid&quot;).makeNodeId;
var ObjectTypeIds = require(&quot;lib/opcua_node_ids&quot;).ObjectTypeIds;



OPCUAServer.prototype.raiseEvent = function (eventType, options) {

    var self = this;

    if (!self.engine.addressSpace) {
        console.log(&quot;addressSpace missing&quot;);
        return;
    }

    var server = self.engine.addressSpace.findNode(&quot;Server&quot;);

    if (!server) {
        // throw new Error(&quot;OPCUAServer#raiseEvent : cannot find Server object&quot;);
        return;
    }
    var eventTypeNode = self.engine.addressSpace.findEventType(eventType);

    if (eventTypeNode) {
        //xx console.log(&quot;RAISING EVENT  nodeid = &quot;, eventTypeNode.nodeId.toString(), eventTypeNode.browseName.toString(), &quot; from server&quot;);
        return server.raiseEvent(eventTypeNode, options);
    } else {
        console.warn(&quot; cannot find event type &quot;,eventType);
    }
};


/**
 * ensure that action is performed on a valid session object,
 * @method _apply_on_SessionObject
 * @private
 */
OPCUAServer.prototype._apply_on_SessionObject = function (ResponseClass, message, channel, action_to_perform) {

    assert(_.isFunction(action_to_perform));

    function sendError(statusCode) {
        return g_sendError(channel, message, ResponseClass, statusCode);
    }

    var response;
    /* istanbul ignore next */
    if (!message.session || message.session_statusCode !== StatusCodes.Good) {

        var errMessage = &quot;INVALID SESSION  !! &quot;;
        debugLog(errMessage.red.bold);
        response = new ResponseClass({responseHeader: {serviceResult: message.session_statusCode}});
        return channel.send_response(&quot;MSG&quot;, response, message);
    }

    assert(message.session_statusCode === StatusCodes.Good);

    // OPC UA Specification 1.02 part 4 page 26
    // When a  Session  is terminated, all outstanding requests on the  Session  are aborted and
    // Bad_SessionClosed  StatusCodes  are returned to the  Client. In addition,   the  Server  deletes the entry
    // for the  Client  from its  SessionDiagnostics Array  Variable  and notifies any other  Clients  who were
    // subscribed to this entry.
    if (message.session.status === &quot;closed&quot;) {

        //note : use StatusCodes.BadSessionClosed , for pending message for this session
        //xx console.log(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxx message.session.status &quot;.red.bold,message.session.status.toString().cyan);
        return sendError(StatusCodes.BadSessionIdInvalid);
    }

    if (message.session.status !== &quot;active&quot;) {

        // mark session as being screwed ! so it cannot be activated anymore
        message.session.status = &quot;screwed&quot;;

        //note : use StatusCodes.BadSessionClosed , for pending message for this session
        return sendError(StatusCodes.BadSessionNotActivated);
    }


    // lets also reset the session watchdog so it doesn&#x27;t
    // (Sessions are terminated by the Server automatically if the Client fails to issue a Service request on the Session
    // within the timeout period negotiated by the Server in the CreateSession Service response. )
    assert(_.isFunction(message.session.keepAlive));
    message.session.keepAlive();

    action_to_perform(message.session, message, channel);

};

/**
 * @method _on_CloseSessionRequest
 * @param message
 * @param channel
 * @private
 */
OPCUAServer.prototype._on_CloseSessionRequest = function (message, channel) {

    var server = this;

    var request = message.request;
    assert(request instanceof CloseSessionRequest);

    var response;

    message.session_statusCode = StatusCodes.Good;

    function sendError(statusCode) {
        return g_sendError(channel, message, CloseSessionResponse, statusCode);
    }

    // do not use _apply_on_SessionObject
    //this._apply_on_SessionObject(CloseSessionResponse, message, channel, function (session) {
    //});

    var session = message.session;
    if (!session) {
        return sendError(StatusCodes.BadSessionIdInvalid);
    }

    if (session.status === &quot;new&quot;) {
        // session has been created but not activated !
        // nevertheless, we should be able to close this session
        //xxx return sendError(StatusCodes.BadSessionNotActivated);
    }

    var deleteSubscriptions = request.deleteSubscriptions || false;
    server.engine.closeSession(request.requestHeader.authenticationToken, deleteSubscriptions);

    response = new CloseSessionResponse({});
    channel.send_response(&quot;MSG&quot;, response, message);
};

function limitInputArray(nodeArray, maxNodes) {

    assert(_.isArray(nodeArray));
    assert(_.isNumber(maxNodes));
    // limit size of nodeArray array to maxNodes
    if (maxNodes &amp;&amp; maxNodes &lt; nodeArray.length) {
        // clipping  nodesToRead to maxRead
        nodeArray.splice(maxNodes, nodeArray.length);
        assert(nodeArray.length === maxNodes);
        return true; // limited
    }
    return false; //
}

// browse services
OPCUAServer.prototype._on_BrowseRequest = function (message, channel) {

    var request = message.request;
    assert(request instanceof BrowseRequest);
    var server = this;
    var diagnostic = {};

    function sendError(statusCode, diagnotisc) {
        return g_sendError(channel, message, BrowseResponse, statusCode, diagnotisc);
    }

    this._apply_on_SessionObject(BrowseResponse, message, channel, function (session) {
        var response;
        // test view
        if (request.view &amp;&amp; !request.view.viewId.isEmpty()) {
            //xx console.log(&quot;xxxx &quot;,request.view.toString());
            //xx console.log(&quot;xxxx NodeClas&quot;,View.prototype.nodeClass);
            var theView = server.engine.addressSpace.findNode(request.view.viewId);
            if (theView &amp;&amp; theView.constructor.nodeClass !== View.prototype.nodeClass) {
                // Error: theView is not a View
                diagnostic.localizedText = {text: &quot;blah&quot;};
                theView = null;
            }
            if (!theView) {
                return sendError(StatusCodes.BadViewIdUnknown, diagnostic);
            }
        }


        if (!request.nodesToBrowse || request.nodesToBrowse.length === 0) {
            return sendError(StatusCodes.BadNothingToDo);
        }

        // ToDo: limit results to requestedMaxReferencesPerNode
        var requestedMaxReferencesPerNode = request.requestedMaxReferencesPerNode;

        limitInputArray(request.nodesToBrowse, server.engine.serverCapabilities.operationLimits.maxNodesPerBrowse);

        var results = [];
        assert(request.nodesToBrowse[0]._schema.name === &quot;BrowseDescription&quot;);
        results = server.engine.browse(request.nodesToBrowse);
        assert(results[0]._schema.name === &quot;BrowseResult&quot;);

        // handle continuation point and requestedMaxReferencesPerNode
        results = results.map(function (result) {
            assert(!result.continuationPoint);
            var r = session.continuationPointManager.register(requestedMaxReferencesPerNode, result.references);
            assert(r.statusCode === StatusCodes.Good);
            r.statusCode = result.statusCode;
            return r;
        });

        response = new BrowseResponse({
            results: results,
            diagnosticInfos: null
        });
        channel.send_response(&quot;MSG&quot;, response, message);
    });
};
OPCUAServer.prototype._on_BrowseNextRequest = function (message, channel) {


    var request = message.request;
    assert(request instanceof BrowseNextRequest);
    //xx var server = this;
    function sendError(statusCode, diagnotisc) {
        return g_sendError(channel, message, BrowseNextResponse, statusCode, diagnotisc);
    }

    this._apply_on_SessionObject(BrowseNextResponse, message, channel, function (session) {

        var response;

        if (!request.continuationPoints || request.continuationPoints.length === 0) {
            return sendError(StatusCodes.BadNothingToDo);
        }

        // A Boolean parameter with the following values:

        var results;
        if (request.releaseContinuationPoints) {
            //releaseContinuationPoints = TRUE
            //   passed continuationPoints shall be reset to free resources in
            //   the Server. The continuation points are released and the results
            //   and diagnosticInfos arrays are empty.
            results = request.continuationPoints.map(function (continuationPoint) {
                return session.continuationPointManager.cancel(continuationPoint);
            });

        } else {
            // let extract data from continuation points

            // releaseContinuationPoints = FALSE
            //   passed continuationPoints shall be used to get the next set of
            //   browse information.
            results = request.continuationPoints.map(function (continuationPoint) {
                return session.continuationPointManager.getNext(continuationPoint);
            });
        }

        response = new BrowseNextResponse({
            results: results,
            diagnosticInfos: null
        });
        channel.send_response(&quot;MSG&quot;, response, message);
    });
};

// read services
OPCUAServer.prototype._on_ReadRequest = function (message, channel) {

    var server = this;
    var request = message.request;
    assert(request instanceof ReadRequest);
    function sendError(statusCode, diagnotisc) {
        return g_sendError(channel, message, ReadResponse, statusCode, diagnotisc);
    }

    this._apply_on_SessionObject(ReadResponse, message, channel, function (session) {

        var response;

        var results = [];

        var timestampsToReturn = request.timestampsToReturn;

        if (timestampsToReturn === TimestampsToReturn.Invalid) {
            return sendError(StatusCodes.BadTimestampsToReturnInvalid);
        }

        if (request.maxAge &lt; 0) {
            return sendError(StatusCodes.BadMaxAgeInvalid);
        }

        request.nodesToRead = request.nodesToRead || [];

        if (!request.nodesToRead || request.nodesToRead.length &lt;= 0) {
            return sendError(StatusCodes.BadNothingToDo);
        }

        assert(request.nodesToRead[0]._schema.name === &quot;ReadValueId&quot;);
        assert(request.timestampsToReturn);

        // limit size of nodesToRead array to maxNodesPerRead
        limitInputArray(request.nodesToRead, server.engine.serverCapabilities.operationLimits.maxNodesPerRead);

        // ask for a refresh of asynchronous variables
        server.engine.refreshValues(request.nodesToRead, function (err) {

            assert(!err, &quot; error not handled here , fix me&quot;);

            results = server.engine.read(request);

            assert(results[0]._schema.name === &quot;DataValue&quot;);
            assert(results.length === request.nodesToRead.length);

            response = new ReadResponse({
                results: results,
                diagnosticInfos: null
            });

            assert(response.diagnosticInfos.length === 0);

            channel.send_response(&quot;MSG&quot;, response, message);
        });

    });

};
/*
 // write services
 // OPCUA Specification 1.02 Part 3 : 5.10.4 Write
 // This Service is used to write values to one or more Attributes of one or more Nodes. For constructed
 // Attribute values whose elements are indexed, such as an array, this Service allows Clients to write
 // the entire set of indexed values as a composite, to write individual elements or to write ranges of
 // elements of the composite.
 // The values are written to the data source, such as a device, and the Service does not return until it writes
 // the values or determines that the value cannot be written. In certain cases, the Server will successfully
 // to an intermediate system or Server, and will not know if the data source was updated properly. In these cases,
 // the Server should report a success code that indicates that the write was not verified.
 // In the cases where the Server is able to verify that it has successfully written to the data source,
 // it reports an unconditional success.
 */
OPCUAServer.prototype._on_WriteRequest = function (message, channel) {

    var server = this;
    var request = message.request;
    assert(request instanceof WriteRequest);
    assert(!request.nodesToWrite || _.isArray(request.nodesToWrite));
    function sendError(statusCode, diagnotisc) {
        return g_sendError(channel, message, WriteResponse, statusCode, diagnotisc);
    }

    var response;

    if (!request.nodesToWrite || request.nodesToWrite.length === 0) {
        return sendError(StatusCodes.BadNothingToDo);
    }

    assert(request.nodesToWrite[0]._schema.name === &quot;WriteValue&quot;);
    server.engine.write(request.nodesToWrite, function (err, results) {
        assert(!err);
        assert(_.isArray(results));
        assert(results.length === request.nodesToWrite.length);
        response = new WriteResponse({
            results: results,
            diagnosticInfos: null
        });
        channel.send_response(&quot;MSG&quot;, response, message);
    });

};

/*=== private
 *
 * perform the read operation on a given node for a monitored item.
 * this method DOES NOT apply to Variable Values attribute
 *
 * @param self
 * @param oldValue
 * @param node
 * @param itemToMonitor
 * @private
 */
function monitoredItem_read_and_record_value(self, oldValue, node, itemToMonitor,callback) {

    assert(self instanceof MonitoredItem);
    assert(oldValue instanceof DataValue);
    assert(itemToMonitor.attributeId === AttributeIds.Value);

    var dataValue = node.readAttribute(itemToMonitor.attributeId, itemToMonitor.indexRange, itemToMonitor.dataEncoding);

    callback(null,dataValue);
}

/*== private
 * @method monitoredItem_read_and_record_value_async
 * this method applies to Variable Values attribute
 * @param self
 * @param oldValue
 * @param node
 * @param itemToMonitor
 * @private
 */
function monitoredItem_read_and_record_value_async(self, oldValue, node, itemToMonitor,callback) {

    assert(itemToMonitor.attributeId === AttributeIds.Value);
    assert(self instanceof MonitoredItem);
    assert(oldValue instanceof DataValue);
    // do it asynchronously ( this is only valid for value attributes )
    assert(itemToMonitor.attributeId === AttributeIds.Value);

    node.readValueAsync(function (err, dataValue) {
        callback(err,dataValue);
    });
}



function build_scanning_node_function(addressSpace, monitoredItem, itemToMonitor) {

    //assert(addressSpace instanceof AddressSpace);
    assert(addressSpace.constructor.name === &quot;AddressSpace&quot;);
    assert(itemToMonitor instanceof ReadValueId);

    var node = addressSpace.findNode(itemToMonitor.nodeId);

    /* istanbul ignore next */
    if (!node) {

        console.log(&quot; INVALID NODE ID  , &quot;, itemToMonitor.nodeId.toString());
        dump(itemToMonitor);
        return function (oldData,callback) {
            callback(null,new DataValue({
                statusCode: StatusCodes.BadNodeIdUnknown,
                value: {dataType: DataType.Null, value: 0}
            }));
        };
    }

    monitoredItem.node = node;

    if (itemToMonitor.attributeId === AttributeIds.Value) {

        var monitoredItem_read_and_record_value_func =
            (itemToMonitor.attributeId === AttributeIds.Value &amp;&amp; _.isFunction(node.readValueAsync)) ?
                monitoredItem_read_and_record_value_async :
                monitoredItem_read_and_record_value;

        return function (oldDataValue,callback) {
            assert(this instanceof MonitoredItem);
            assert(oldDataValue instanceof DataValue);
            assert(_.isFunction(callback));
            monitoredItem_read_and_record_value_func(this, oldDataValue, node, itemToMonitor,callback);
        };


    } else {
        // Attributes, other than the  Value  Attribute, are only monitored for a change in value.
        // The filter is not used for these  Attributes. Any change in value for these  Attributes
        // causes a  Notification  to be  generated.

        // only record value when it has changed
        return function (oldDataValue,callback) {

            var self = this;
            assert(self instanceof MonitoredItem);
            assert(oldDa&lt;taValue instanceof DataValue);
            assert(_.isFunction(callback));

            var newDataValue = node.readAttribute(itemToMonitor.attributeId);
            callback(null,newDataValue);
        };
    }
}


function prepareMonitoredItem(addressSpace, monitoredItem) {
    var itemToMonitor = monitoredItem.itemToMonitor;
    var readNodeFunc = build_scanning_node_function(addressSpace, monitoredItem, itemToMonitor);
    monitoredItem.samplingFunc = readNodeFunc;
}


OPCUAServer.MAX_SUBSCRIPTION = 150;

// subscription services
OPCUAServer.prototype._on_CreateSubscriptionRequest = function (message, channel) {

    var server = this;
    var engine = server.engine;
    var addressSpace = engine.addressSpace;

    var request = message.request;
    assert(request instanceof CreateSubscriptionRequest);
    function sendError(statusCode, diagnotisc) {
        return g_sendError(channel, message, CreateSubscriptionResponse, statusCode, diagnotisc);
    }

    this._apply_on_SessionObject(CreateSubscriptionResponse, message, channel, function (session) {

        if (session.currentSubscriptionCount &gt;= OPCUAServer.MAX_SUBSCRIPTION) {
            return sendError(StatusCodes.BadTooManySubscriptions);
        }

        var subscription = session.createSubscription(request);

        subscription.on(&quot;monitoredItem&quot;, function (monitoredItem) {
            prepareMonitoredItem(addressSpace, monitoredItem);
        });

        var response = new CreateSubscriptionResponse({
            subscriptionId: subscription.id,
            revisedPublishingInterval: subscription.publishingInterval,
            revisedLifetimeCount: subscription.lifeTimeCount,
            revisedMaxKeepAliveCount: subscription.maxKeepAliveCount
        });
        channel.send_response(&quot;MSG&quot;, response, message);
    });
};

OPCUAServer.prototype._on_DeleteSubscriptionsRequest = function (message, channel) {

    var request = message.request;
    assert(request instanceof DeleteSubscriptionsRequest);

    function sendError(statusCode, diagnotisc) {
        return g_sendError(channel, message, DeleteSubscriptionsResponse, statusCode, diagnotisc);
    }

    this._apply_on_SessionObject(DeleteSubscriptionsResponse, message, channel, function (session) {

        var response;

        if (!request.subscriptionIds || request.subscriptionIds.length === 0) {
            return sendError(StatusCodes.BadNothingToDo);
        }

        var results = request.subscriptionIds.map(function (subscriptionId) {
            return session.deleteSubscription(subscriptionId);
        });
        response = new DeleteSubscriptionsResponse({
            results: results
        });
        channel.send_response(&quot;MSG&quot;, response, message);
    });
};


OPCUAServer.prototype.prepare = function (message, channel) {

    var server = this;
    var request = message.request;

    // --- check that session is correct
    var authenticationToken = request.requestHeader.authenticationToken;
    var session = server.getSession(authenticationToken, /*activeOnly*/true);
    message.session = session;
    if (!session) {
        message.session_statusCode = StatusCodes.BadSessionIdInvalid;
        return;
    }

    //xx console.log(&quot;xxxx channel &quot;,channel.secureChannelId,session.secureChannelId);
    // --- check that provided session matches session attached to channel
    if (channel.secureChannelId !== session.secureChannelId) {
        if (!(request instanceof ActivateSessionRequest)) {
            console.log(&quot;ERROR: channel.secureChannelId !== session.secureChannelId&quot;.red.bgWhite, channel.secureChannelId, session.secureChannelId);
            //xx console.log(&quot;trace&quot;,(new Error()).stack);
        }
        message.session_statusCode = StatusCodes.BadSecureChannelIdInvalid;

    } else if (channel_has_session(channel,session))  {
        message.session_statusCode = StatusCodes.Good;
    } else {
        // session ma y have been moved to a different channel
        message.session_statusCode = StatusCodes.BadSecureChannelIdInvalid;
    }
};


OPCUAServer.prototype._on_CreateMonitoredItemsRequest = function (message, channel) {

    var server = this;
    var engine = server.engine;
    var addressSpace = engine.addressSpace;

    var request = message.request;
    assert(request instanceof CreateMonitoredItemsRequest);
    function sendError(statusCode, diagnotisc) {
        return g_sendError(channel, message, CreateMonitoredItemsResponse, statusCode, diagnotisc);
    }

    this._apply_on_SessionObject(CreateMonitoredItemsResponse, message, channel, function (session) {

        var response;

        var subscription = session.getSubscription(request.subscriptionId);
        if (!subscription) {
            return sendError(StatusCodes.BadSubscriptionIdInvalid);
        }

        subscription.resetLifeTimeAndKeepAliveCounters();

        var timestampsToReturn = request.timestampsToReturn;

        if (timestampsToReturn === TimestampsToReturn.Invalid) {
            return sendError(StatusCodes.BadTimestampsToReturnInvalid);
        }

        if (!request.itemsToCreate || request.itemsToCreate.length === 0) {
            return sendError(StatusCodes.BadNothingToDo);
        }

        var results = request.itemsToCreate.map(
            subscription.createMonitoredItem.bind(subscription, addressSpace, timestampsToReturn));

        response = new CreateMonitoredItemsResponse({
            responseHeader: {serviceResult: StatusCodes.Good},
            results: results
            //,diagnosticInfos: []
        });
        channel.send_response(&quot;MSG&quot;, response, message);

    });

};

var ModifySubscriptionRequest = subscription_service.ModifySubscriptionRequest;
var ModifySubscriptionResponse = subscription_service.ModifySubscriptionResponse;

OPCUAServer.prototype._on_ModifySubscriptionRequest = function (message, channel) {

    var request = message.request;
    assert(request instanceof ModifySubscriptionRequest);
    function sendError(statusCode, diagnotisc) {
        return g_sendError(channel, message, ModifySubscriptionResponse, statusCode, diagnotisc);
    }

    this._apply_on_SessionObject(ModifySubscriptionResponse, message, channel, function (session) {

        var subscription = session.getSubscription(request.subscriptionId);
        var response;

        if (!subscription) {
            return sendError(StatusCodes.BadSubscriptionIdInvalid);
        }
        subscription.subscriptionDiagnostics.modifyCount += 1;

        subscription.resetLifeTimeAndKeepAliveCounters();

        subscription.modify(request);

        response = new ModifySubscriptionResponse({
            revisedPublishingInterval: subscription.publishingInterval,
            revisedLifetimeCount: subscription.lifeTimeCount,
            revisedMaxKeepAliveCount: subscription.maxKeepAliveCount
        });
        channel.send_response(&quot;MSG&quot;, response, message);
    });
};


OPCUAServer.prototype._on_ModifyMonitoredItemsRequest = function (message, channel) {
    var request = message.request;
    assert(request instanceof ModifyMonitoredItemsRequest);

    function sendError(statusCode) {
        return g_sendError(channel, message, ModifyMonitoredItemsResponse, statusCode);
    }

    this._apply_on_SessionObject(ModifyMonitoredItemsResponse, message, channel, function (session) {

        var subscription = session.getSubscription(request.subscriptionId);
        var response;

        if (!subscription) {
            return sendError(StatusCodes.BadSubscriptionIdInvalid);
        }
        subscription.resetLifeTimeAndKeepAliveCounters();

        var timestampsToReturn = request.timestampsToReturn;
        if (timestampsToReturn === TimestampsToReturn.Invalid) {
            return sendError(StatusCodes.BadTimestampsToReturnInvalid);
        }
        if (!request.itemsToModify || request.itemsToModify.length === 0) {
            return sendError(StatusCodes.BadNothingToDo);
        }

        var itemsToModify = request.itemsToModify; // MonitoredItemModifyRequest

        function modifyMonitoredItem(item) {

            var monitoredItemId = item.monitoredItemId;
            var monitoredItem = subscription.getMonitoredItem(monitoredItemId);
            if (!monitoredItem) {
                return new MonitoredItemModifyResult({statusCode: StatusCodes.BadMonitoredItemIdInvalid});
            }

            // adjust samplingInterval if === -1
            if (item.requestedParameters.samplingInterval === -1 ) {
                item.requestedParameters.samplingInterval = subscription.publishingInterval;
            }

            return monitoredItem.modify(timestampsToReturn, item.requestedParameters);
        }

        var results = itemsToModify.map(modifyMonitoredItem);
        response = new ModifyMonitoredItemsResponse({
            results: results
        });

        channel.send_response(&quot;MSG&quot;, response, message);


    });

};

OPCUAServer.prototype._on_PublishRequest = function (message, channel) {

    var request = message.request;
    assert(request instanceof PublishRequest);

    this._apply_on_SessionObject(PublishResponse, message, channel, function (session) {
        assert(session);
        assert(session.publishEngine); // server.publishEngine doesn&#x27;t exists, OPCUAServer has probably shut down already
        session.publishEngine._on_PublishRequest(request, function (request, response) {
            channel.send_response(&quot;MSG&quot;, response, message);
        });
    });
};


OPCUAServer.prototype._on_SetPublishingModeRequest = function (message, channel) {

    var request = message.request;
    assert(request instanceof SetPublishingModeRequest);
    function sendError(statusCode, diagnotisc) {
        return g_sendError(channel, message, SetPublishingModeResponse, statusCode, diagnotisc);
    }

    this._apply_on_SessionObject(SetPublishingModeResponse, message, channel, function (session) {

        var response;
        var publishingEnabled = request.publishingEnabled;
        var subscriptionIds = request.subscriptionIds;

        var results = subscriptionIds.map(function (subscriptionId) {

            var subscription = session.getSubscription(subscriptionId);
            if (!subscription) {
                return StatusCodes.BadSubscriptionIdInvalid;
            }
            subscription.resetLifeTimeAndKeepAliveCounters();

            return subscription.setPublishingMode(publishingEnabled);
        });

        response = new SetPublishingModeResponse({
            results: results,
            diagnosticInfos: null
        });
        channel.send_response(&quot;MSG&quot;, response, message);
    });
};


OPCUAServer.prototype._on_DeleteMonitoredItemsRequest = function (message, channel) {

    var request = message.request;
    assert(request instanceof DeleteMonitoredItemsRequest);
    function sendError(statusCode) {
        return g_sendError(channel, message, DeleteMonitoredItemsResponse, statusCode);
    }

    this._apply_on_SessionObject(DeleteMonitoredItemsResponse, message, channel, function (session) {

        var response;

        var subscriptionId = request.subscriptionId;
        assert(subscriptionId !== null);

        var subscription = session.getSubscription(subscriptionId);
        if (!subscription) {
            debugLog(&quot;Cannot find subscription &quot;, subscriptionId);
            return sendError(StatusCodes.BadSubscriptionIdInvalid);
        }


        subscription.resetLifeTimeAndKeepAliveCounters();

        if (!request.monitoredItemIds || request.monitoredItemIds.length === 0) {
            return sendError(StatusCodes.BadNothingToDo);
        }

        var results = request.monitoredItemIds.map(function (monitoredItemId) {
            return subscription.removeMonitoredItem(monitoredItemId);
        });

        response = new DeleteMonitoredItemsResponse({
            results: results,
            diagnosticInfos: null
        });

        channel.send_response(&quot;MSG&quot;, response, message);
    });
};

OPCUAServer.prototype._on_RepublishRequest = function (message, channel) {

    var request = message.request;
    assert(request instanceof RepublishRequest);

    function sendError(statusCode) {
        return g_sendError(channel, message, RepublishResponse, statusCode);
    }

    this._apply_on_SessionObject(RepublishResponse, message, channel, function (session) {

        var response;

        var subscription = session.getSubscription(request.subscriptionId);

        if (!subscription) {
            return sendError(StatusCodes.BadSubscriptionIdInvalid);
        }

        // update diagnostic counter
        subscription.subscriptionDiagnostics.republishRequestCount += 1;

        subscription.resetLifeTimeAndKeepAliveCounters();

        var retransmitSequenceNumber = request.retransmitSequenceNumber;

        var msgSequence = subscription.getMessageForSequenceNumber(retransmitSequenceNumber);

        if (!msgSequence) {
            return sendError(StatusCodes.BadMessageNotAvailable);
        }
        response = new RepublishResponse({
            responseHeader: {
                serviceResult: StatusCodes.Good
            },
            notificationMessage: msgSequence.notification
        });

        channel.send_response(&quot;MSG&quot;, response, message);
    });
};

var SetMonitoringModeRequest = subscription_service.SetMonitoringModeRequest;
var SetMonitoringModeResponse = subscription_service.SetMonitoringModeResponse;

// Bad_NothingToDo
// Bad_TooManyOperations
// Bad_SubscriptionIdInvalid
// Bad_MonitoringModeInvalid
OPCUAServer.prototype._on_SetMonitoringModeRequest = function (message, channel) {

    var request = message.request;
    assert(request instanceof SetMonitoringModeRequest);
    function sendError(statusCode) {
        return g_sendError(channel, message, SetMonitoringModeResponse, statusCode);
    }

    this._apply_on_SessionObject(RepublishResponse, message, channel, function (session) {
        var response;

        var subscription = session.getSubscription(request.subscriptionId);

        if (!subscription) {
            return sendError(StatusCodes.BadSubscriptionIdInvalid);
        }
        subscription.resetLifeTimeAndKeepAliveCounters();

        if (!request.monitoredItemIds  || request.monitoredItemIds.length === 0) {
            return sendError(StatusCodes.BadNothingToDo);
        }

        var monitoringMode = request.monitoringMode;

        if (monitoringMode === subscription_service.MonitoringMode.Invalid) {
            return sendError(StatusCodes.BadMonitoringModeInvalid);
        }

        var results = request.monitoredItemIds.map(function (monitoredItemId) {

            var monitoredItem = subscription.getMonitoredItem(monitoredItemId);
            if (!monitoredItem) {
                return StatusCodes.BadMonitoredItemIdInvalid;
            }
            monitoredItem.setMonitoringMode(monitoringMode);
            return StatusCodes.Good;
        });

        response = new SetMonitoringModeResponse({
            results: results
        });
        channel.send_response(&quot;MSG&quot;, response, message);
    });

};

// _on_TranslateBrowsePathsToNodeIds service
OPCUAServer.prototype._on_TranslateBrowsePathsToNodeIdsRequest = function (message, channel) {

    var request = message.request;
    assert(request instanceof TranslateBrowsePathsToNodeIdsRequest);
    var server = this;

    function sendError(statusCode) {
        return g_sendError(channel, message, TranslateBrowsePathsToNodeIdsResponse, statusCode);
    }

    this._apply_on_SessionObject(TranslateBrowsePathsToNodeIdsResponse, message, channel, function (session) {

        if (!request.browsePath || request.browsePath.length === 0) {
            return sendError(StatusCodes.BadNothingToDo);
        }

        var browsePathResults = request.browsePath.map(function (browsePath) {
            return server.engine.browsePath(browsePath);
        });
        var response = new TranslateBrowsePathsToNodeIdsResponse({
            results: browsePathResults,
            diagnosticInfos: null
        });
        channel.send_response(&quot;MSG&quot;, response, message);

    });

};


// Symbolic Id                   Description
//----------------------------  ----------------------------------------------------------------------------------------
// Bad_NodeIdInvalid             Used to indicate that the specified object is not valid.
//
// Bad_NodeIdUnknown             Used to indicate that the specified object is not valid.
//
// Bad_ArgumentsMissing          The client did not specify all of the input arguments for the method.
// Bad_UserAccessDenied
//
// Bad_MethodInvalid             The method id does not refer to a method for the specified object.
// Bad_OutOfRange                Used to indicate that an input argument is outside the acceptable range.
// Bad_TypeMismatch              Used to indicate that an input argument does not have the correct data type.
//                               A ByteString is structurally the same as a one dimensional array of Byte.
//                               A server shall accept a ByteString if an array of Byte is expected.
// Bad_NoCommunication

var getMethodDeclaration_ArgumentList = require(&quot;lib/datamodel/argument_list&quot;).getMethodDeclaration_ArgumentList;
var verifyArguments_ArgumentList = require(&quot;lib/datamodel/argument_list&quot;).verifyArguments_ArgumentList;

function callMethod(session, callMethodRequest, callback) {
    /* jshint validthis: true */
    var server = this;
    var addressSpace = server.engine.addressSpace;

    var objectId = callMethodRequest.objectId;
    var methodId = callMethodRequest.methodId;
    var inputArguments = callMethodRequest.inputArguments;

    assert(objectId instanceof NodeId);
    assert(methodId instanceof NodeId);


    var response = getMethodDeclaration_ArgumentList(addressSpace, objectId, methodId);

    if (response.statusCode !== StatusCodes.Good) {
        return callback(null, {statusCode: response.statusCode});
    }
    var methodDeclaration = response.methodDeclaration;

    // verify input Parameters
    var methodInputArguments = methodDeclaration.getInputArguments();

    response = verifyArguments_ArgumentList(methodInputArguments, inputArguments);
    if (response.statusCode !== StatusCodes.Good) {
        return callback(null, response);
    }

    var methodObj = addressSpace.findNode(methodId);

    // invoke method on object
    var context = {
        session: session,
        object:  addressSpace.findNode(objectId)
    };

    methodObj.execute(inputArguments, context, function (err, callMethodResponse) {

        /* istanbul ignore next */
        if (err) {
            return callback(err);
        }


        callMethodResponse.inputArgumentResults = response.inputArgumentResults;
        assert(callMethodResponse.statusCode);


        if (callMethodResponse.statusCode === StatusCodes.Good) {
            assert(_.isArray(callMethodResponse.outputArguments));
        }

        assert(_.isArray(callMethodResponse.inputArgumentResults));
        assert(callMethodResponse.inputArgumentResults.length === methodInputArguments.length);

        return callback(null, callMethodResponse);
    });

}




// Call Service Result Codes
// Symbolic Id Description
// Bad_NothingToDo       See Table 165 for the description of this result code.
// Bad_TooManyOperations See Table 165 for the description of this result code.
//
OPCUAServer.prototype._on_CallRequest = function (message, channel) {

    var server = this;
    var request = message.request;
    assert(request instanceof CallRequest);
    function sendError(statusCode) {
        return g_sendError(channel, message, CallResponse, statusCode);
    }

    this._apply_on_SessionObject(CallResponse, message, channel, function (session) {

        var response;

        if (!request.methodsToCall || request.methodsToCall.length === 0) {
            return sendError(StatusCodes.BadNothingToDo);
        }

        // the MaxNodesPerMethodCall Property indicates the maximum size of the methodsToCall array when
        // a Client calls the Call Service.
        var maxNodesPerMethodCall = server.engine.serverCapabilities.operationLimits.maxNodesPerMethodCall;
        maxNodesPerMethodCall = maxNodesPerMethodCall &lt;=0 ? 1000: maxNodesPerMethodCall;

        if (request.methodsToCall.length &gt;= maxNodesPerMethodCall) {
            return sendError(StatusCodes.BadTooManyOperations);
        }

        async.map(request.methodsToCall, callMethod.bind(server, session), function (err, results) {
            assert(!err);
            assert(_.isArray(results));
            response = new CallResponse({results: results});
            channel.send_response(&quot;MSG&quot;, response, message);

        }, function (err) {
            /* istanbul ignore next */
            if (err) {
                channel.send_error_and_abort(StatusCodes.BadInternalError, err.message, &quot;&quot;, function () {
                });
            }
        });
    });


};


OPCUAServer.prototype._on_RegisterNodesRequest = function (message, channel) {
    var request = message.request;
    assert(request instanceof RegisterNodesRequest);
    //xx var server = this;

    this._apply_on_SessionObject(RegisterNodesResponse, message, channel, function (/*session*/) {

        var response;

        if (!request.nodesToRegister || request.nodesToRegister.length === 0) {
            response = new RegisterNodesResponse({responseHeader: {serviceResult: StatusCodes.BadNothingToDo}});
            return channel.send_response(&quot;MSG&quot;, response, message);
        }

        response = new RegisterNodesResponse({
            registeredNodeIds: request.nodesToRegister,
        });
        channel.send_response(&quot;MSG&quot;, response, message);
    });
};
OPCUAServer.prototype._on_UnregisterNodesRequest = function (message, channel) {

    var request = message.request;
    assert(request instanceof UnregisterNodesRequest);
    //xx var server = this;

    this._apply_on_SessionObject(UnregisterNodesResponse, message, channel, function (session) {

        var response;

        if (!request.nodesToUnregister || request.nodesToUnregister.length === 0) {
            response = new UnregisterNodesResponse({responseHeader: {serviceResult: StatusCodes.BadNothingToDo}});
            return channel.send_response(&quot;MSG&quot;, response, message);
        }

        response = new UnregisterNodesResponse({});

        channel.send_response(&quot;MSG&quot;, response, message);
    });

};

OPCUAServer.prototype._on_Cancel =  function (message, channel) {
    return g_sendError(channel, message, session_service.CancelResponse, StatusCodes.BadNotImplemented);
};


// NodeManagement Service Set Overview
// This Service Set defines Services to add and delete AddressSpace Nodes and References between them. All added
// Nodes continue to exist in the AddressSpace even if the Client that created them disconnects from the Server.
//
var node_managment_service = require(&quot;lib/services/node_management_service&quot;);

OPCUAServer.prototype._on_AddNodes= function (message, channel) {
    return g_sendError(channel, message, node_managment_service.AddNodesResponse, StatusCodes.BadNotImplemented);
};

OPCUAServer.prototype._on_AddReferences= function (message, channel) {
    return g_sendError(channel, message, node_managment_service.AddReferencesResponse, StatusCodes.BadNotImplemented);
};
OPCUAServer.prototype._on_DeleteNodes= function (message, channel) {
    return g_sendError(channel, message, node_managment_service.DeleteNodesResponse, StatusCodes.BadNotImplemented);
};
OPCUAServer.prototype._on_DeleteReferences= function (message, channel) {
    return g_sendError(channel, message, node_managment_service.DeleteReferencesResponse, StatusCodes.BadNotImplemented);
};


// Query Service
OPCUAServer.prototype._on_QueryFirst= function (message, channel) {
    return g_sendError(channel, message, query_service.QueryFirstResponse, StatusCodes.BadNotImplemented);
};
OPCUAServer.prototype._on_QueryNext = function (message, channel) {
    return g_sendError(channel, message, query_service.QueryNextResponse, StatusCodes.BadNotImplemented);
};


var historizing_service = require(&quot;lib/services/historizing_service&quot;);
OPCUAServer.prototype._on_HistoryUpdate = function (message, channel) {
    return g_sendError(channel, message, historizing_service.HistorizingUpdateResponse, StatusCodes.BadNotImplemented);
};


/**
 * @method registerServer
 * @async
 * @param discovery_server_endpointUrl
 * @param callback
 */
OPCUAServer.prototype._registerServer = function (discovery_server_endpointUrl, isOnLine, outer_callback) {


    function findSecureEndpoint(endpoints) {
        var endpoint = endpoints.filter(function (e) {
            return e.securityMode === MessageSecurityMode.SIGNANDENCRYPT;
        });
        if (endpoint.length === 0) {
            endpoint = endpoints.filter(function (e) {
                return e.securityMode === MessageSecurityMode.SIGN;
            });
        }
        if (endpoint.length === 0) {
            endpoint = endpoints.filter(function (e) {
                return e.securityMode === MessageSecurityMode.NONE;
            });
        }
        return endpoint[0];
    }

    var async = require(&quot;async&quot;);
    var MessageSecurityMode = endpoints_service.MessageSecurityMode;
    var securityPolicy_m = require(&quot;lib/misc/security_policy&quot;);
    var SecurityPolicy = securityPolicy_m.SecurityPolicy;

    var OPCUAClientBase = require(&quot;lib/client/client_base&quot;).OPCUAClientBase;

    var self = this;
    assert(self.serverType, &quot; must have a valid server Type&quot;);

    var client = new OPCUAClientBase();

    var discoveryServerCertificate = null;

    async.series([

        function (callback) {

            client.connect(discovery_server_endpointUrl, callback);

        },
        function (callback) {

            client.getEndpointsRequest(function (err, endpoints) {
                if (!err) {

                    var endpoint = findSecureEndpoint(endpoints);
                    assert(endpoint);
                    assert(endpoint.serverCertificate);
                    discoveryServerCertificate = endpoint.serverCertificate;
                }
                callback(err);
            });
        },


        function (callback) {
            client.disconnect(callback);
        },

        function (callback) {


            var options = {
                securityMode: MessageSecurityMode.SIGN,
                securityPolicy: SecurityPolicy.Basic128Rsa15,
                serverCertificate: discoveryServerCertificate
            };
            client = new OPCUAClientBase(options);

            client.connect(discovery_server_endpointUrl, function (err) {
                if (!err) {
                    callback(err);
                } else {
                    console.log(&quot; cannot register server to discovery server &quot; + discovery_server_endpointUrl);
                    console.log(&quot;   &quot; + err.message);
                    console.log(&quot; make sure discovery server is up and running.&quot;);
                    client.disconnect(function () {
                        callback(err);
                    });
                }
            });
        },

        function (callback) {

            var discoveryUrls = self.getDiscoveryUrls();

            var request = new RegisterServerRequest({
                server: {

                    // The globally unique identifier for the Server instance. The serverUri matches
                    // the applicationUri from the ApplicationDescription defined in 7.1.
                    serverUri: self.serverInfo.applicationUri,

                    // The globally unique identifier for the Server product.
                    productUri: self.serverInfo.productUri,
                    serverNames: [
                        {locale: &quot;en&quot;, text: self.serverInfo.productName}
                    ],
                    serverType: self.serverType,
                    gatewayServerUri: null,
                    discoveryUrls: discoveryUrls,
                    semaphoreFilePath: null,
                    isOnline: isOnLine
                }
            });

            //xx console.log(&quot;request&quot;,request.toString());

            client.performMessageTransaction(request, function (err, response) {
                if (!err) {
                    // RegisterServerResponse
                    assert(response instanceof RegisterServerResponse);
                }
                callback(err);
            });
        },

        function (callback) {
            client.disconnect(callback);
        }

    ], function (err) {
        if (err) {
            console.log(&quot;error &quot;, err.message);
        }
        outer_callback(err);
    });

};

OPCUAServer.prototype.registerServer = function (discovery_server_endpointUrl, callback) {
    this._registerServer(discovery_server_endpointUrl, true, callback);
};

OPCUAServer.prototype.unregisterServer = function (discovery_server_endpointUrl, callback) {
    this._registerServer(discovery_server_endpointUrl, false, callback);
};

OPCUAServer.prototype.__defineGetter__(&quot;isAuditing&quot;,function(){
    return false;
});

exports.OPCUAServerEndPoint = OPCUAServerEndPoint;
exports.OPCUAServer = OPCUAServer;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
